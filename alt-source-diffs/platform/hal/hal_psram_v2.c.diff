local: https://raw.githubusercontent.com/pine64/OpenPineBuds/533d01aee617f24dfe9cda124fbb20b6efbe2f73/platform/hal/hal_psram_v2.c
remote: https://raw.githubusercontent.com/OneDeuxTriSeiGo/device_soc_bestechnic/c0502a1345f2f5b7ffc7f38b5374be0fcb42a487/bes2600/liteos_m/sdk/bsp/platform/hal/hal_psram_v2.c
diff -sw local remote
---

1c1,5
< /***************************************************************************
---
> /*
>  * Copyright (c) 2021 Bestechnic (Shanghai) Co., Ltd. All rights reserved.
>  * Licensed under the Apache License, Version 2.0 (the "License");
>  * you may not use this file except in compliance with the License.
>  * You may obtain a copy of the License at
3,4c7
<  * Copyright 2015-2019 BES.
<  * All rights reserved. All unpublished rights reserved.
---
>  *     http://www.apache.org/licenses/LICENSE-2.0
6,16c9,15
<  * No part of this work may be used or reproduced in any form or by any
<  * means, or stored in a database or retrieval system, without prior written
<  * permission of BES.
<  *
<  * Use of this work is governed by a license granted by BES.
<  * This work contains confidential and proprietary information of
<  * BES. which is protected by copyright, trade secret,
<  * trademark and other intellectual property rights.
<  *
<  ****************************************************************************/
< #if defined(CHIP_HAS_PSRAM) && (CHIP_PSRAM_CTRL_VER >= 2)
---
>  * Unless required by applicable law or agreed to in writing, software
>  * distributed under the License is distributed on an "AS IS" BASIS,
>  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
>  * See the License for the specific language governing permissions and
>  * limitations under the License.
>  */
> #if defined(CHIP_HAS_PSRAM) && (CHIP_PSRAM_CTRL_VER == 2 || CHIP_PSRAM_CTRL_VER == 3)
19a19
> #include "cmsis.h"
24a25
> #include "hal_chipid.h"
32c33,47
< //#define PSRAM_WRAP_ENABLE
---
> #ifdef CHIP_BEST2003
>     #ifndef PSRAM_APS3208K
>         #define PSRAM_WRAP_ENABLE
>     #endif
> #endif
> 
> #ifndef PSRAM_PAGE_SIZE
> #ifdef PSRAM_XCCELA_MODE
> // APS128xxN APS256xxN APS512xxN
> #define PSRAM_PAGE_SIZE                     2048
> #else /* PSRAM_XCCELA_MODE */
> // APS3208K APS6408L
> #define PSRAM_PAGE_SIZE                     1024
> #endif /* PSRAM_XCCELA_MODE */
> #endif
34d48
< //#define PSRAM_DEBUG
149,150c163,166
< static const uint32_t psram_cfg_clk = 48*1000*1000;
< 
---
> #ifdef FPGA
>     static const uint32_t psram_cfg_clk = 20 * 1000 * 1000;
>     static const uint32_t psram_run_clk = 20 * 1000 * 1000;
> #else /*FPGA*/
151a168
>         static const uint32_t psram_cfg_clk = 48 * 1000 * 1000;
154c171
< #error "invalid PSRAMUHS_SPEED"
---
>         #error "invalid PSRAM_SPEED"
155a173
> #endif /*FPGA*/
233c251
<     for (int i = 0; i < len; i++) {
---
>     for (uint32_t i = 0; i < len; i++) {
240c258
<     for (int i = 0; i < len; i++) {
---
>     for (uint32_t i = 0; i < len; i++) {
303a322,325
> #ifdef PSRAM_APS3208K
>     hal_sys_timer_delay_us(1);
>     psram_single_cmd(MEMIF_RST);
> #endif
310,311c332
< 
< #if PSRAMSIZE == 0x800000
---
> #ifdef PSRAM_XCCELA_MODE
320a342,382
> 
>     reg = 0;
>     if (clk <= 66000000) {
>         val = 0;
>     } else if (clk <= 109000000) {
>         val = 1;
>     } else if (clk <= 133000000) {
>         val = 2;
>     } else if (clk <= 166000000) {
>         val = 3;
>     } else {
>         val = 4;
>     }
>     // Latency type: Variable
>     val = MR0_DRIVE_STR(3) | MR0_READ_LATENCY(val);
>     psram_write_reg(reg, val);
> 
>     reg = 4;
>     if (clk <= 66000000) {
>         val = 0;
>     } else if (clk <= 109000000) {
>         val = 4;
>     } else if (clk <= 133000000) {
>         val = 2;
>     } else if (clk <= 166000000) {
>         val = 6;
>     } else {
>         val = 1;
>     }
>     //Always 4x Refresh
>     val = MR4_PASR(0) | MR4_WRITE_LATENCY(val);
>     psram_write_reg(reg, val);
> #else /*PSRAM_XCCELA_MODE*/
> #ifndef PSRAM_APS3208K
>     reg = 8;
> #ifdef PSRAM_WRAP_ENABLE
>     // Wrap 32
>     val = MR8_BL(1);
> #else
>     // Wrap 1k
>     val = MR8_BL(0x3);
321a384,385
>     psram_write_reg(reg, val);
> #endif /* PSRAM_APS3208K */
346a411,419
> #endif /*PSRAM_XCCELA_MODE*/
> }
> 
> static uint32_t hal_psram_phy_read_reg(__I uint32_t *addr)
> {
> #if defined(CHIP_BEST2003) || defined(CHIP_BEST2006)
>     *addr;
> #endif
>     return *addr;
355c428
<     val = psram_phy->REG_050;
---
>     val = hal_psram_phy_read_reg(&psram_phy->REG_050);
366c439
<         range = 0;
---
>         range = 1;
369a443
>     hal_sys_timer_delay_us(100);
371a446
>     hal_sys_timer_delay_us(100);
377c452,530
<     val = psram_phy->REG_048;
---
>     val = hal_psram_phy_read_reg(&psram_phy->REG_048);
>     val |= PSRAM_ULP_PHY_REG_LDO_PU | PSRAM_ULP_PHY_REG_LDO_PRECHARGE;
>     psram_phy->REG_048 = val;
>     hal_sys_timer_delay_us(100);
> 
>     val &= ~PSRAM_ULP_PHY_REG_LDO_PRECHARGE;
>     val = SET_BITFIELD(val, PSRAM_ULP_PHY_REG_LDO_IEN1, 0xd);
>     val = SET_BITFIELD(val, PSRAM_ULP_PHY_REG_LDO_IEN2, 0x7);
>     val = SET_BITFIELD(val, PSRAM_ULP_PHY_REG_LDO_VTUNE, 0x2);
> #if CHIP_PSRAM_CTRL_VER >= 3
>     val = SET_BITFIELD(val, PSRAM_ULP_PHY_REG_LDO_RES, 0x4);
> #endif
>     psram_phy->REG_048 = val;
>     hal_sys_timer_delay_us(100);
> 
> #if CHIP_PSRAM_CTRL_VER >= 3
> #ifdef CHIP_BEST2003
>     // chip 2006
>     if (hal_get_chip_metal_id() >= HAL_CHIP_METAL_ID_8) {
>         psram_mc->REG_200 |= PSRAM_ULP_PHY_REG_CEB_PU;
>     }
> #endif
> #endif
>     val = hal_psram_phy_read_reg(&psram_phy->REG_04C);
>     val |= PSRAM_ULP_PHY_REG_PSRAM_PU;
>     //val = SET_BITFIELD(val, PSRAM_ULP_PHY_REG_PSRAM_SWRC, 0x3);
>     val = SET_BITFIELD(val, PSRAM_ULP_PHY_REG_PSRAM_TXDRV, 0x3);
>     psram_phy->REG_04C = val;
>     hal_sys_timer_delay_us(100);
> 
>     val = hal_psram_phy_read_reg(&psram_phy->REG_050);
>     val |= PSRAM_ULP_PHY_REG_DLL_PU;
>     val = SET_BITFIELD(val, PSRAM_ULP_PHY_REG_DLL_SWRC, 0x0);
>     val &= ~PSRAM_ULP_PHY_REG_BYPASS_DECIMATION;
>     psram_phy->REG_050 = val;
>     hal_sys_timer_delay_us(100);
> 
>     val |= PSRAM_ULP_PHY_REG_DLL_RESETB;
>     psram_phy->REG_050 = val;
>     hal_sys_timer_delay_us(100);
> 
>     hal_psram_phy_dll_config(clk);
>     hal_sys_timer_delay_us(500);
> }
> POSSIBLY_UNUSED void hal_psram_phy_sleep()
> {
>     uint32_t val;
> 
>     val = hal_psram_phy_read_reg(&psram_phy->REG_04C);
>     val &= ~PSRAM_ULP_PHY_REG_PSRAM_PU;
>     psram_phy->REG_04C = val;
> 
>     val = hal_psram_phy_read_reg(&psram_phy->REG_050);
>     val &= ~PSRAM_ULP_PHY_REG_DLL_PU;
>     psram_phy->REG_050 = val;
> 
>     val = hal_psram_phy_read_reg(&psram_phy->REG_048);
>     val &= ~PSRAM_ULP_PHY_REG_LDO_PU;
>     psram_phy->REG_048 = val;
> }
> 
> static void hal_psram_digphy_init()
> {
> #if CHIP_PSRAM_CTRL_VER >= 3
>     uint32_t val;
>     val = hal_psram_phy_read_reg(&psram_phy->REG_004);
> #ifdef PSRAM_XCCELA_MODE
>     val |= PSRAM_ULP_PHY_ADDR_4BYTES_EN | PSRAM_ULP_PHY_DQS_DM_MERGE_EN;
>     val &= ~PSRAM_ULP_PHY_PHY_DUMMY_CYC_EN;
> #endif
>     val |= PSRAM_ULP_PHY_CTRL_DELAY(1);
>     val &= ~PSRAM_ULP_PHY_PHY_DLY_AUTO_EN;
>     psram_phy->REG_004 = val;
> #endif
> }
> POSSIBLY_UNUSED static void hal_psram_phy_wakeup()
> {
>     uint32_t val;
>     val = hal_psram_phy_read_reg(&psram_phy->REG_048);
383,385c536,538
<     val = SET_BITFIELD(val, PSRAM_ULP_PHY_REG_LDO_IEN1, 0xc);
<     val = SET_BITFIELD(val, PSRAM_ULP_PHY_REG_LDO_IEN2, 0x5);
<     val = SET_BITFIELD(val, PSRAM_ULP_PHY_REG_LDO_VTUNE, 0x0);
---
>     val = SET_BITFIELD(val, PSRAM_ULP_PHY_REG_LDO_IEN1, 0xd);
>     val = SET_BITFIELD(val, PSRAM_ULP_PHY_REG_LDO_IEN2, 0x7);
>     val = SET_BITFIELD(val, PSRAM_ULP_PHY_REG_LDO_VTUNE, 0x2);
388c541
<     val = psram_phy->REG_04C;
---
>     val = hal_psram_phy_read_reg(&psram_phy->REG_04C);
390c543
<     val = SET_BITFIELD(val, PSRAM_ULP_PHY_REG_PSRAM_SWRC, 0x3);
---
>     //val = SET_BITFIELD(val, PSRAM_ULP_PHY_REG_PSRAM_SWRC, 0x3);
394c547
<     val = psram_phy->REG_050;
---
>     val = hal_psram_phy_read_reg(&psram_phy->REG_050);
404c557,559
<     hal_psram_phy_dll_config(clk);
---
>     do {
>         val = hal_psram_phy_read_reg(&psram_phy->REG_058);
>     } while ((val & PSRAM_ULP_PHY_DLL_LOCK) == 0);
406,407c561
< 
< static void hal_psram_mc_set_timing(uint32_t clk)
---
> static void hal_psram_mc_set_timing(uint32_t clk, bool init)
410c564,599
< 
---
> #ifdef PSRAM_XCCELA_MODE
>     if (init) {
>         val = PSRAM_ULP_MC_WRITE_LATENCY(1);
>     } else {
>         if (clk <= 66000000) {
>             val = PSRAM_ULP_MC_WRITE_LATENCY(3);
>         } else if (clk <= 109000000) {
>             val = PSRAM_ULP_MC_WRITE_LATENCY(4);
>         } else if (clk <= 133000000) {
>             val = PSRAM_ULP_MC_WRITE_LATENCY(5);
>         } else if (clk <= 166000000) {
>             val = PSRAM_ULP_MC_WRITE_LATENCY(6);
>         } else {
>             val = PSRAM_ULP_MC_WRITE_LATENCY(7);
>         }
>     }
>     psram_mc->REG_028 = val;
>     if (clk <= 66000000) {
>         val = PSRAM_ULP_MC_READ_LATENCY(3);
>     } else if (clk <= 109000000) {
>         val = PSRAM_ULP_MC_READ_LATENCY(4);
>     } else if (clk <= 133000000) {
>         val = PSRAM_ULP_MC_READ_LATENCY(5);
>     } else if (clk <= 166000000) {
>         val = PSRAM_ULP_MC_READ_LATENCY(6);
>     } else {
>         val = PSRAM_ULP_MC_READ_LATENCY(7);
>     }
>     psram_mc->REG_02C = val;
>     // tCPH >= 24 ns
>     val = (clk / 1000000 * 24 + (1000 - 1)) / 1000;
>     psram_mc->REG_058 = PSRAM_ULP_MC_T_CPHR(val);
>     psram_mc->REG_060 = PSRAM_ULP_MC_T_CPHW(val);
>     psram_mc->REG_068 = PSRAM_ULP_MC_T_MRR(val);
>     psram_mc->REG_06C = PSRAM_ULP_MC_T_MRS(val);
> #else /*PSRAM_XCCELA_MODE*/
417d605
< #if (CHIP_PSRAM_CTRL_VER == 2)
430,436c618
< #else
<     // Min latency: 2 cycles
<     psram_mc->REG_02C = PSRAM_ULP_MC_READ_LATENCY(2);
< #endif
<     // tRC >= 55 ns
<     val = (clk / 1000000 * 55 + (1000 - 1)) / 1000;
<     psram_mc->REG_050 = PSRAM_ULP_MC_T_RC(val);
---
>     // tCPH
442c624
< #ifdef CHIP_BEST2001
---
> #if CHIP_PSRAM_CTRL_VER == 2
445a628,631
> #endif /*PSRAM_XCCELA_MODE*/
>     // tRC >= 55 ns
>     val = (clk / 1000000 * 55 + (1000 - 1)) / 1000;
>     psram_mc->REG_050 = PSRAM_ULP_MC_T_RC(val);
452,453c638,639
<     // tHS >= 4 us
<     val = clk / 1000000 * 4 + 1;
---
>     // tHS >= 2 us
>     val = clk / 1000000 * 2 + 1;
455c641
<     // tXPHS in [60 ns, 4 us]
---
>     // tXPHS in [60 ns, 2 us]
458,459c644,645
<     // tXHS >= 70 us
<     val = clk / 1000000 * 70 + 1;
---
>     // tXHS >= 100 us
>     val = clk / 1000000 * 100 + 1;
462c648
<     // NOP dummy cycles, same as tXPHS in [60 ns, 4 us]
---
>     // NOP dummy cycles, same as tXPHS in [60 ns, 2 us]
464c650,654
<     psram_mc->REG_0A0 = PSRAM_ULP_MC_STOP_CLK_IN_NOP | PSRAM_ULP_MC_NOP_DMY_CYC(val);
---
>     psram_mc->REG_0A0 = PSRAM_ULP_MC_STOP_CLK_IN_NOP |
> #ifdef PSRAM_XCCELA_MODE
>                         PSRAM_ULP_MC_STOP_CLK_IN_TCPH |
> #endif
>                         PSRAM_ULP_MC_NOP_DMY_CYC(val);
467a658,692
> static void hal_psram_phy_wait_lock()
> {
> #ifndef PROGRAMMER
>     uint32_t val;
>     uint32_t val_50;
>     uint32_t count = 0;
>     val = hal_psram_phy_read_reg(&psram_phy->REG_048);
>     val_50 = hal_psram_phy_read_reg(&psram_phy->REG_050);
> #endif
>     while (1) {
>         uint32_t val_58;
>         val_58 = hal_psram_phy_read_reg(&psram_phy->REG_058);
>         if ((val_58 & PSRAM_ULP_PHY_DLL_LOCK))
>             break;
> #ifndef PROGRAMMER
>         if (count++ > 20) {
>             if (GET_BITFIELD(val, PSRAM_ULP_PHY_REG_LDO_VTUNE) == 0x2) {
>                 val = SET_BITFIELD(val, PSRAM_ULP_PHY_REG_LDO_VTUNE, 0x1);
>                 psram_phy->REG_048 = val;
>             } else if (GET_BITFIELD(val, PSRAM_ULP_PHY_REG_LDO_VTUNE) == 0x1) {
>                 val = SET_BITFIELD(val, PSRAM_ULP_PHY_REG_LDO_VTUNE, 0x2);
>                 psram_phy->REG_048 = val;
>                 if (GET_BITFIELD(val_50, PSRAM_ULP_PHY_REG_DLL_RANGE) == 0x1) {
>                     val_50 = SET_BITFIELD(val_50, PSRAM_ULP_PHY_REG_DLL_RANGE, 0x2);
>                     psram_phy->REG_050 = val_50;
>                 }
>             }
>             count = 0;
>         }
> #endif
>         hal_sys_timer_delay_us(100);
>     }
> }
> 
> POSSIBLY_UNUSED
469a695
>     uint32_t val;
472,474c698,700
<     while ((psram_phy->REG_058 & PSRAM_ULP_PHY_DLL_LOCK) == 0);
< 
<     delay = GET_BITFIELD(psram_phy->REG_058, PSRAM_ULP_PHY_DLL_DLY_IN);
---
>     hal_psram_phy_wait_lock();
>     val = hal_psram_phy_read_reg(&psram_phy->REG_058);
>     delay = GET_BITFIELD(val, PSRAM_ULP_PHY_DLL_DLY_IN);
480a707
>     hal_sys_timer_delay_us(100);
485,488c712,717
< #ifdef PSRAM_DUAL_8BIT
<     psram_mc->REG_000 = PSRAM_ULP_MC_CHIP_BIT;
< #else
<     psram_mc->REG_000 = 0;
---
>     uint32_t val = 0;
> #if CHIP_PSRAM_CTRL_VER >= 3
> #if defined(PSRAM_DUAL_8BIT)
>     val |= PSRAM_ULP_MC_CHIP_BIT;
> #elif defined(PSRAM_X16_MODE)
>     val |= PSRAM_ULP_MC_CHIP_X16;
489a719,731
> #ifdef PSRAM_SQPI_MODE
>     val |= PSRAM_ULP_MC_SQPI_MODE;
>     val |= (PSRAM_ULP_PHY_IDLE_DQ_OEN | PSRAM_ULP_PHY_IDLE_DQS_OEN);
> #else /* PSRAM_SQPI_MODE */
>     val |= PSRAM_ULP_MC_OPI_MODE;
>     val = SET_BITFIELD(val, PSRAM_ULP_MC_CHIP_CA_PATTERN, 0x1);
> #endif /* PSRAM_SQPI_MODE */
> #else /* CHIP_PSRAM_CTRL_VER == 2 */
> #if defined(PSRAM_DUAL_8BIT)
>     val |= PSRAM_ULP_MC_CHIP_BIT;
> #endif
> #endif /* CHIP_PSRAM_CTRL_VER >= 3 */
>     psram_mc->REG_000 = val;
492,493c734,735
< #ifndef CHIP_BEST2001
<         PSRAM_ULP_MC_ENTRY_SLEEP_IDLE |
---
> #if CHIP_PSRAM_CTRL_VER >= 3
>         //PSRAM_ULP_MC_ENTRY_SLEEP_IDLE |
499c741
<     psram_mc->REG_034 = PSRAM_ULP_MC_BURST_LENGTH(1) | PSRAM_ULP_MC_PAGE_BOUNDARY(0);
---
>     val = PSRAM_ULP_MC_BURST_LENGTH(1);
501,504c743,764
<     // 8MB psram
<     // Burst len: 1K, page: 1K
<     psram_mc->REG_034 = PSRAM_ULP_MC_BURST_LENGTH(4) | PSRAM_ULP_MC_PAGE_BOUNDARY(0);
< #endif
---
>     if (PSRAM_PAGE_SIZE == 512) {
>         val = PSRAM_ULP_MC_BURST_LENGTH(7);
>     } else if (PSRAM_PAGE_SIZE == 1024) {
>         val = PSRAM_ULP_MC_BURST_LENGTH(4);
>     } else if (PSRAM_PAGE_SIZE == 2048) {
>         val = PSRAM_ULP_MC_BURST_LENGTH(5);
>     } else {
>         // 4K
>         val = PSRAM_ULP_MC_BURST_LENGTH(6);
>     }
> #endif /* PSRAM_WRAP_ENABLE */
>     if (PSRAM_PAGE_SIZE == 512) {
>         val |= PSRAM_ULP_MC_PAGE_BOUNDARY(3);
>     } else if (PSRAM_PAGE_SIZE == 1024) {
>         val |= PSRAM_ULP_MC_PAGE_BOUNDARY(0);
>     } else if (PSRAM_PAGE_SIZE == 2048) {
>         val |= PSRAM_ULP_MC_PAGE_BOUNDARY(1);
>     } else {
>         // 4K
>         val |= PSRAM_ULP_MC_PAGE_BOUNDARY(2);
>     }
>     psram_mc->REG_034 = val;
508c768,772
<     psram_mc->REG_03C = PSRAM_ULP_MC_HIGH_PRI_LEVEL(4);
---
> #if CHIP_PSRAM_CTRL_VER == 2
>     psram_mc->REG_03C = PSRAM_ULP_MC_HIGH_PRI_LEVEL(1);
> #else
>     psram_mc->REG_03C = PSRAM_ULP_MC_HIGH_PRI_LEVEL(7);
> #endif
517a782
>     hal_sys_timer_delay_us(100);
519c784,785
<     hal_psram_mc_set_timing(clk);
---
>     hal_psram_mc_set_timing(clk, true);
>     hal_sys_timer_delay_us(100);
522,523c788
< 
<     hal_psram_init_calib();
---
>     hal_sys_timer_delay_us(100);
530,531c795,796
< #ifndef CHIP_BEST2001
<         psram_mc->REG_024 &= ~PSRAM_ULP_MC_ENTRY_SLEEP_IDLE;
---
> #if CHIP_PSRAM_CTRL_VER >= 3
>         //psram_mc->REG_024 &= ~PSRAM_ULP_MC_ENTRY_SLEEP_IDLE;
533a799,812
> #if CHIP_PSRAM_CTRL_VER >= 3
> #ifdef PSRAM_XCCELA_MODE
>         int val = psram_mc->REG_028;
>         psram_mc->REG_028 = PSRAM_ULP_MC_WRITE_LATENCY(1);
>         __DSB();
>         hal_psramip_mc_busy_wait();
> #endif /* PSRAM_XCCELA_MODE */
>         psram_write_reg(0x6, 0xF0);
>         hal_psramip_mc_busy_wait();
> #ifdef PSRAM_XCCELA_MODE
>         psram_mc->REG_028 = val;
>         hal_psramip_mc_busy_wait();
> #endif /* PSRAM_XCCELA_MODE */
> #else
535a815
> #endif
536a817
>     hal_psram_phy_sleep();
540a822,823
>     hal_psram_phy_wakeup();
>     hal_psramip_set_cmd(MEMIF_NOP);
542,543c825,826
< #ifndef CHIP_BEST2001
<     psram_mc->REG_024 |= PSRAM_ULP_MC_ENTRY_SLEEP_IDLE;
---
> #if CHIP_PSRAM_CTRL_VER >= 3
>     //psram_mc->REG_024 |= PSRAM_ULP_MC_ENTRY_SLEEP_IDLE;
556c839
< #ifdef HAL_CMU_FREQ_T
---
> #ifdef HAL_CMU_FREQ_390M
568c851
<     hal_sys_timer_delay_us(3);
---
>     hal_sys_timer_delay_us(500);
569a853,854
> 
> #if !defined(FPGA) && !defined(SIMU)
571c856,857
<     hal_psram_mc_set_timing(clk);
---
> #endif
>     hal_psram_mc_set_timing(clk, false);
574a861,903
>     hal_sys_timer_delay_us(100);
> }
> void hal_psram_snoop_enable()
> {
> #if CHIP_PSRAM_CTRL_VER >= 3
>     psram_mc->REG_044 &= ~PSRAM_ULP_MC_SNP_DISABLE;
> #endif
> }
> void hal_psram_snoop_disable()
> {
>     psram_mc->REG_044 |= PSRAM_ULP_MC_SNP_DISABLE;
> }
> 
> void hal_psram_write_buffer_invalidate(void)
> {
>     uint32_t level;
>     uint32_t start = hal_sys_timer_get();
> 
>     __DSB();
>     do {
>         level = GET_BITFIELD(psram_mc->REG_404, PSRAM_ULP_MC_WB_FILL_LEVEL);
>         if (level == 0) {
>             break;
>         }
>     } while (hal_sys_timer_get() - start < MS_TO_TICKS(1));
> 
>     ASSERT(level == 0, "%s: Drain timeout: level=%u status=0x%08X", __func__, level, psram_mc->REG_404);
> 
>     psram_mc->REG_044 |= PSRAM_ULP_MC_WB_INVALID;
>     __DSB();
> }
> 
> static void hal_psram_phy_restore_range(uint32_t range)
> {
>     uint32_t val;
> 
>     val = hal_psram_phy_read_reg(&psram_phy->REG_050);
>     val &= ~PSRAM_ULP_PHY_REG_DLL_RESETB | PSRAM_ULP_PHY_REG_DLL_CK_RDY;
>     psram_phy->REG_050 = val;
>     val = SET_BITFIELD(val, PSRAM_ULP_PHY_REG_DLL_RANGE, range);
>     psram_phy->REG_050 = val;
>     val |= PSRAM_ULP_PHY_REG_DLL_RESETB | PSRAM_ULP_PHY_REG_DLL_CK_RDY;
>     psram_phy->REG_050 = val;
576a906,969
> static void psram_mc_reset(uint32_t range)
> {
>     hal_cmu_reset_set(HAL_CMU_MOD_H_PSRAM);
>     hal_cmu_reset_set(HAL_CMU_MOD_O_PSRAM);
>     hal_cmu_reset_clear(HAL_CMU_MOD_H_PSRAM);
>     hal_cmu_reset_clear(HAL_CMU_MOD_O_PSRAM);
> 
>     hal_cmu_mem_set_freq(HAL_CMU_FREQ_104M);
>     hal_psram_phy_init(psram_cfg_clk);
>     hal_sys_timer_delay_us(30);
>     hal_psram_mc_init(psram_cfg_clk);
> #if !defined(FPGA) && !defined(SIMU)
>     hal_psram_init_calib();
> #endif
>     psram_reset();
>     psram_chip_timing_config(psram_run_clk, true);
>     hal_psram_phy_restore_range(range);
> #if !defined(FPGA) && !defined(SIMU)
>     hal_psram_init_calib();
> #endif
> 
>     hal_psram_snoop_disable();
> }
> POSSIBLY_UNUSED static bool psramphy_check_tx_ceb_valid(uint32_t range)
> {
>     int retry = 2;
>     while (retry--) {
>         int count = 0;
>         hal_psramip_flush_all_fifo();
>         hal_psramip_xfer_addr_len(0x100000, 8);
>         hal_psramip_set_cmd(MEMIF_READ);
>         while (hal_psramip_rx_fifo_empty()) {
>             if (count++ > 10) {
>                 //PSRAM_TRACE(1, "%s, rx fifo empty, return false", __FUNCTION__);
>                 psram_mc_reset(range);
>                 hal_psram_snoop_disable();
>                 return false;
>             }
>         }
>     }
>     return true;
> }
> POSSIBLY_UNUSED static bool psramphy_check_tx_clk_valid(uint32_t range)
> {
>     uint32_t time;
>     uint32_t val;
> 
>     time = hal_fast_sys_timer_get();
>     psram_mc->REG_01C = PSRAM_ULP_MC_MGR_TX_FIFO_CLR | PSRAM_ULP_MC_MGR_RX_FIFO_CLR;
>     hal_psramip_xfer_addr_len(0xAA55AA55, 1);
>     hal_psramip_set_cmd(MEMIF_READ);
>     while (hal_psramip_rx_fifo_empty()) {
>         if (FAST_TICKS_TO_US(hal_fast_sys_timer_get() - time) > 5) {
>             val = hal_psram_phy_read_reg(&psram_phy->REG_004);
>             val |= PSRAM_ULP_PHY_PHY_LOOPBACK_EN;
>             psram_phy->REG_004 = val;
>             while (hal_psramip_mc_busy());
>             val &= ~PSRAM_ULP_PHY_PHY_LOOPBACK_EN;
>             psram_phy->REG_004 = val;
>             return false;
>         }
>     }
>     return true;
> }
579c972,974
<     int i;
---
>     uint32_t i;
>     uint32_t val, val0, val1;
>     uint32_t val2, val3;
581c976,978
<     for (i=0; i<0x8; ++i) {
---
>     volatile uint32_t *psram_base1 = (volatile uint32_t *)(PSRAM_NC_BASE + 0x100000);
> 
>     for (i = 0; i < 0x100; ++i) {
582a980
>         *(psram_base1 + i) = 0xffffffff;
584,585c982,988
<     for (i=0; i<0x8; ++i) {
<         *(psram_base+i) = ((i << 0) | (i << 8) | (i << 16) | (i << 24));
---
>     for (i = 0; i < 0x100; ++i) {
>         val = i & 0xFF;
>         val = val | (val << 8) | (val << 16) | (val << 24);
>         val0 = (val & 0x00FF00FF) | ((~val) & 0xFF00FF00);
>         val1 = (val & 0xFF0000FF) | ((~val) & 0x00FFFF00);
>         *(psram_base + i) = val0;
>         *(psram_base1 + i) = val1;
586a990
> 
589,592c993,1005
<     for (i=0; i<0x8; ++i) {
<         uint32_t check_val = *(psram_base+i);
<         if (check_val != ((i << 0) | (i << 8) | (i << 16) | (i << 24))) {
<             //PSRAM_TRACE(2,"write fail, %p = 0x%x", (uint32_t)(psram_base+i), check_val);
---
>     for (i = 0; i < 0x100; ++i) {
>         val = i & 0xFF;
>         val = val | (val << 8) | (val << 16) | (val << 24);
>         val0 = (val & 0x00FF00FF) | ((~val) & 0xFF00FF00);
>         val1 = (val & 0xFF0000FF) | ((~val) & 0x00FFFF00);
>         val2 = *(psram_base + i);
>         val3 = *(psram_base1 + i);
>         if (val2 != val0) {
>             //PSRAM_TRACE(3, "%s, i:%d, 0x%x, 0x%x", __FUNCTION__, i, val2, val0);
>             return false;
>         }
>         if (val3 != val1) {
>             //PSRAM_TRACE(3, "%s, i:%d, 0x%x, 0x%x", __FUNCTION__, i, val3, val1);
600a1014
>     #define BUFFER_SIZE  0x20
603c1017
<     uint8_t tx_dqs, rx_dqs;
---
>     POSSIBLY_UNUSED uint8_t tx_dqs, rx_dqs, tx_ceb, tx_clk;
605,606c1019,1033
<     uint8_t cali_valid[0x20][0x20];
<     uint8_t cali_value[0x20][0x20];
---
>     POSSIBLY_UNUSED int8_t left_bound;
>     POSSIBLY_UNUSED int8_t right_bound;
>     bool cali_valid[BUFFER_SIZE][BUFFER_SIZE];
>     uint8_t cali_value[BUFFER_SIZE][BUFFER_SIZE];
>     POSSIBLY_UNUSED bool valid_array[BUFFER_SIZE];
> 
> #ifdef PSRAM_WINDOW_TEST
>     static int8_t last_left_bound = 0;
>     static int8_t last_right_bound = 0;
>     uint8_t dqs_point = 0;
>     uint8_t dqs_len = 0;
>     static uint8_t last_dqs_point = 0;
>     static uint8_t last_dqs_len = 0;
>     POSSIBLY_UNUSED static uint8_t cali_data[BUFFER_SIZE][BUFFER_SIZE];
> #endif
608c1035
<     ASSERT(range <= (PSRAM_ULP_PHY_DLL_DLY_IN_MASK >> PSRAM_ULP_PHY_DLL_DLY_IN_SHIFT), "ERROR, bad ana phy range:%d", range);
---
>     ASSERT(range <= (PSRAM_ULP_PHY_REG_DLL_RANGE_MASK >> PSRAM_ULP_PHY_REG_DLL_RANGE_SHIFT), "ERROR, bad ana phy range:%d", range);
610c1037
<     val = psram_phy->REG_050;
---
>     val = hal_psram_phy_read_reg(&psram_phy->REG_050);
614a1042
>     hal_sys_timer_delay_us(100);
619c1047
<     while ((psram_phy->REG_058 & PSRAM_ULP_PHY_DLL_LOCK) == 0);
---
>     hal_sys_timer_delay_us(100);
621c1049,1051
<     val = psram_phy->REG_058;
---
>     hal_psram_phy_wait_lock();
> 
>     val = hal_psram_phy_read_reg(&psram_phy->REG_058);
628a1059,1061
> #ifdef PSRAM_WINDOW_TEST
>     TRACE_IMM(TR_ATTR_NO_LF | TR_ATTR_NO_TS | TR_ATTR_NO_ID, ", T/4=0x%02x", delay / 2);
> #endif
630c1063
<         PSRAM_TRACE("%s: bad delay (T/2 > 0x1f). increase range=%d", __func__, range+1);
---
>         PSRAM_TRACE(2, "%s: bad delay (T/2 > 0x1f). increase range=%d", __func__, range + 1);
638,639c1071,1178
<     //volume = (PSRAM_ULP_PHY_REG_PSRAM_TX_DQS_DLY_MASK>>PSRAM_ULP_PHY_REG_PSRAM_TX_DQS_DLY_SHIFT) / inc_delay;
<     volume = MIN(delay, (PSRAM_ULP_PHY_REG_PSRAM_TX_DQS_DLY_MASK>>PSRAM_ULP_PHY_REG_PSRAM_TX_DQS_DLY_SHIFT)) / inc_delay;
---
> #if CHIP_PSRAM_CTRL_VER >= 3
>     tx_ceb = delay / 2;
>     tx_clk = delay / 2 + 2;
> #else /*CHIP_PSRAM_CTRL_VER == 2*/
>     tx_ceb = delay * 5 / 6; // t/4 + t/6
>     tx_clk = (delay * 11 + 8) / 16;// t/4 + t/8 - t/32
> #endif
> 
>     volume = (PSRAM_ULP_PHY_REG_PSRAM_TX_DQS_DLY_MASK >> PSRAM_ULP_PHY_REG_PSRAM_TX_DQS_DLY_SHIFT) / inc_delay;
>     //PSRAM_TRACE(2, "volume:%d, inc_delay:%d", volume, inc_delay);
> 
> #if 0
>     //calibrate tx_ceb
>     PSRAM_TRACE(0, "cali tx_ceb");
>     left_bound = -1;
>     right_bound = -1;
>     memset(valid_array, 0, sizeof(valid_array));
>     for (tx_ceb = 0; tx_ceb <= volume; tx_ceb++) {
>         bool valid;
> 
>         psram_phy->REG_054 = PSRAM_ULP_PHY_REG_PSRAM_TX_CEB_DLY(tx_ceb * inc_delay) | PSRAM_ULP_PHY_REG_PSRAM_TX_CLK_DLY(delay / 2) |
>                              PSRAM_ULP_PHY_REG_PSRAM_TX_DQS_DLY(delay / 2) | PSRAM_ULP_PHY_REG_PSRAM_RX_DQS_DLY(delay / 2);
> 
>         valid = psramphy_check_tx_ceb_valid(range);
>         PSRAM_TRACE(3, "%s, tx_ceb:0x%x, valid:%d", __FUNCTION__, (tx_ceb * inc_delay), valid);
>         valid_array[tx_ceb] = valid;
>         if (tx_ceb == 0) {
>             if (valid) {
>                 left_bound = tx_ceb;
>                 PSRAM_TRACE(1, "left_bound:0x%x", left_bound * inc_delay);
>             }
>         } else if (tx_ceb == volume) {
>             if (valid) {
>                 right_bound = tx_ceb;//find right bound
>                 PSRAM_TRACE(1, "right_bound:0x%x", right_bound * inc_delay);
>             } else {
>                 if (valid_array[tx_ceb - 1]) {
>                     right_bound = tx_ceb - 1; //find right bound
>                     PSRAM_TRACE(1, "right_bound:0x%x", right_bound * inc_delay);
>                 }
>             }
>         } else {
>             if (valid && !valid_array[tx_ceb - 1]) {
>                 left_bound = tx_ceb;//find left bound
>                 PSRAM_TRACE(1, "left_bound:0x%x", left_bound * inc_delay);
>             } else if (!valid && valid_array[tx_ceb - 1]) {
>                 right_bound = tx_ceb - 1; //find right bound
>                 PSRAM_TRACE(1, "right_bound:0x%x", right_bound * inc_delay);
>                 break;
>             }
>         }
>     }
>     if (left_bound != -1 && right_bound != -1) { // && (right_bound-left_bound>1)) {
>         tx_ceb = (left_bound + right_bound) / 2;
>         PSRAM_TRACE(3, "cali tx_ceb done, tx_ceb:0x%x(0x%x-0x%x)", tx_ceb * inc_delay, left_bound * inc_delay, right_bound * inc_delay);
>     } else {
>         ASSERT(false, "ERROR, tx_ceb need do more cali");
>     }
>     tx_ceb *= inc_delay;
> #endif
> #if 0
>     //calibrate tx_clk
>     PSRAM_TRACE(0, "cali tx_clk");
>     left_bound = -1;
>     right_bound = -1;
>     memset(valid_array, 0, sizeof(valid_array));
>     for (tx_clk = 0; tx_clk <= volume; tx_clk++) {
>         bool valid;
> 
>         psram_phy->REG_054 = PSRAM_ULP_PHY_REG_PSRAM_TX_CEB_DLY(tx_ceb) | PSRAM_ULP_PHY_REG_PSRAM_TX_CLK_DLY(tx_clk * inc_delay) |
>                              PSRAM_ULP_PHY_REG_PSRAM_TX_DQS_DLY(delay / 2) | PSRAM_ULP_PHY_REG_PSRAM_RX_DQS_DLY(delay / 2);
>         valid = psramphy_check_tx_ceb_valid(range);
>         //PSRAM_TRACE(3, "%s, tx_clk:0x%x, valid:%d", __FUNCTION__, (tx_clk*inc_delay), valid);
>         valid_array[tx_clk] = valid;
>         if (tx_clk == 0) {
>             if (valid) {
>                 left_bound = tx_clk;
>                 PSRAM_TRACE(1, "left_bound:0x%x", left_bound * inc_delay);
>             }
>         } else if (tx_clk == volume) {
>             if (valid) {
>                 right_bound = tx_clk;//find right bound
>                 PSRAM_TRACE(1, "right_bound:0x%x", right_bound * inc_delay);
>             } else {
>                 if (valid_array[tx_clk - 1]) {
>                     right_bound = tx_clk - 1; //find right bound
>                     PSRAM_TRACE(1, "right_bound:0x%x", right_bound * inc_delay);
>                 }
>             }
>         } else {
>             if (valid && !valid_array[tx_clk - 1]) {
>                 left_bound = tx_clk;//find left bound
>                 PSRAM_TRACE(1, "left_bound:0x%x", left_bound * inc_delay);
>             } else if (!valid && valid_array[tx_clk - 1]) {
>                 right_bound = tx_clk - 1; //find right bound
>                 PSRAM_TRACE(1, "right_bound:0x%x", right_bound * inc_delay);
>                 break;
>             }
>         }
>     }
>     if (left_bound != -1 && right_bound != -1) { // && (right_bound-left_bound>1)) {
>         tx_clk = (left_bound + right_bound) / 2;
>         PSRAM_TRACE(3, "cali tx_clk done, tx_clk:0x%x(0x%x-0x%x)", tx_clk * inc_delay, left_bound * inc_delay, right_bound * inc_delay);
>     } else {
>         ASSERT(false, "ERROR, tx_clk need do more cali");
>     }
>     tx_clk *= inc_delay;
> #endif
640a1180,1181
> #ifdef PSRAM_WINDOW_TEST    //new added,Use when testing window,2021-08-28
>     volume = (PSRAM_ULP_PHY_REG_PSRAM_TX_DQS_DLY_MASK >> PSRAM_ULP_PHY_REG_PSRAM_TX_DQS_DLY_SHIFT) / inc_delay;
643c1184,1246
<     uint8_t all_valid = 1;
---
>     //calibrate tx_clk
>     PSRAM_TRACE(0, "cali tx_clk");
>     left_bound = -1;
>     right_bound = -1;
>     memset(valid_array, 0, sizeof(valid_array));
>     for (tx_clk = 1; tx_clk <= volume; tx_clk++) {
>         bool valid;
>         tx_ceb = tx_clk - 1;
>         psram_phy->REG_054 = PSRAM_ULP_PHY_REG_PSRAM_TX_CEB_DLY(tx_ceb * inc_delay) | PSRAM_ULP_PHY_REG_PSRAM_TX_CLK_DLY(tx_clk * inc_delay) |
>                              PSRAM_ULP_PHY_REG_PSRAM_TX_DQS_DLY(delay / 2) | PSRAM_ULP_PHY_REG_PSRAM_RX_DQS_DLY(delay / 2);
>         valid = psramphy_check_tx_clk_valid(range);
>         //PSRAM_TRACE(3, "tx_clk:0x%x, valid:%d", (tx_clk*inc_delay), valid);
>         valid_array[tx_clk] = valid;
>         if (tx_clk == 1) {
>             if (valid) {
>                 left_bound = tx_clk;
>                 PSRAM_TRACE(1, "left_bound:0x%x", left_bound * inc_delay);
>             }
>         } else if (tx_clk == volume) {
>             if (valid) {
>                 right_bound = tx_clk;//find right bound
>                 PSRAM_TRACE(1, "right_bound:0x%x", right_bound * inc_delay);
>             } else {
>                 if (valid_array[tx_clk - 1]) {
>                     right_bound = tx_clk - 1; //find right bound
>                     PSRAM_TRACE(1, "right_bound:0x%x", right_bound * inc_delay);
>                 }
>             }
>         } else {
>             if (valid && !valid_array[tx_clk - 1]) {
>                 left_bound = tx_clk;//find left bound
>                 PSRAM_TRACE(1, "left_bound:0x%x", left_bound * inc_delay);
>             } else if (!valid && valid_array[tx_clk - 1]) {
>                 right_bound = tx_clk - 1; //find right bound
>                 PSRAM_TRACE(1, "right_bound:0x%x", right_bound * inc_delay);
>                 break;
>             }
>         }
>     }
>     if (left_bound != -1 && right_bound != -1) {// && (right_bound-left_bound>1)) {
>         tx_clk = (left_bound + right_bound) / 2;
>         PSRAM_TRACE(3, "cali tx_clk done, tx_clk:0x%x(0x%x-0x%x)", tx_clk * inc_delay, left_bound * inc_delay, right_bound * inc_delay);
> 
> #ifdef PSRAM_WINDOW_TEST
>         if ((last_left_bound != left_bound) || (last_right_bound != right_bound)) {
>             last_left_bound = left_bound;
>             last_right_bound = right_bound;
>             TRACE_IMM(TR_ATTR_NO_LF | TR_ATTR_NO_TS | TR_ATTR_NO_ID, ", tx_clk:0x%02x(0x%02x-0x%02x)", tx_clk * inc_delay, left_bound * inc_delay, right_bound * inc_delay);
>         } else {
>             TRACE_IMM(TR_ATTR_NO_LF | TR_ATTR_NO_TS | TR_ATTR_NO_ID, ", **********************");
>         }
> #endif
>     } else {
>         ASSERT(false, "ERROR, tx_clk need do more cali");
>     }
>     tx_ceb = (tx_clk - 1) * inc_delay;
>     tx_clk = tx_clk * inc_delay;
> #endif
> 
>     PSRAM_TRACE(2, "tx_ceb:0x%x, tx_clk:0x%x", tx_ceb, tx_clk);
> 
>     volume = MIN(delay, (PSRAM_ULP_PHY_REG_PSRAM_TX_DQS_DLY_MASK >> PSRAM_ULP_PHY_REG_PSRAM_TX_DQS_DLY_SHIFT)) / inc_delay;
>     PSRAM_TRACE(2, "volume:%d, inc_delay:%d", volume, inc_delay);
644a1248,1249
>     //calibrate tx_dqs and rx_dqs
>     uint8_t all_valid = 1;
648c1253,1257
<             psram_phy->REG_054 = PSRAM_ULP_PHY_REG_PSRAM_TX_CEB_DLY(delay/2) | PSRAM_ULP_PHY_REG_PSRAM_TX_CLK_DLY(delay/2) |
---
> #ifdef PSRAM_XCCELA_MODE
>             psram_phy->REG_054 = PSRAM_ULP_PHY_REG_PSRAM_TX_CEB_DLY(tx_ceb) | PSRAM_ULP_PHY_REG_PSRAM_TX_CLK_DLY(tx_dqs * inc_delay) |
>                                  PSRAM_ULP_PHY_REG_PSRAM_TX_DQS_DLY(0) | PSRAM_ULP_PHY_REG_PSRAM_RX_DQS_DLY(rx_dqs * inc_delay);
> #else
>             psram_phy->REG_054 = PSRAM_ULP_PHY_REG_PSRAM_TX_CEB_DLY(tx_ceb) | PSRAM_ULP_PHY_REG_PSRAM_TX_CLK_DLY(tx_clk) |
649a1259
> #endif
651c1261,1262
<             if (cali_valid[tx_dqs][rx_dqs] == 0)
---
>             //PSRAM_TRACE(3, "tx_dqs:0x%x, rx_dqs:0x%x, valid:%d", tx_dqs*inc_delay, rx_dqs*inc_delay, cali_valid[tx_dqs][rx_dqs]);
>             if (cali_valid[tx_dqs][rx_dqs] == false)
657c1268
<         PSRAM_TRACE(2,"%s: all valid increase range=%d", __func__, range+1);
---
>         //PSRAM_TRACE(2, "%s: all valid increase range=%d", __func__, range+1);
662,663c1273,1274
<     PSRAM_TRACENOCRLF_NOTS("\r\n\r\n ---------------------------------------------------------------------- \r\n");
<     PSRAM_TRACENOCRLF_NOTS("    rx_dqs");
---
>     PSRAM_TRACENOCRLF_NOTS(0, "\r\n\r\n ---------------------------------------------------------------------- \r\n");
>     PSRAM_TRACENOCRLF_NOTS(0, "    rx_dqs");
665c1276
<         PSRAM_TRACENOCRLF_NOTS(" %2d ", tx_dqs*inc_delay);
---
>         PSRAM_TRACENOCRLF_NOTS(1, " %2d ", tx_dqs * inc_delay);
667c1278
<     PSRAM_TRACENOCRLF_NOTS("\r\n");
---
>     PSRAM_TRACENOCRLF_NOTS(0, "\r\n");
669c1280
<         PSRAM_TRACENOCRLF_NOTS("tx_dqs:%2d ", tx_dqs*inc_delay);
---
>         PSRAM_TRACENOCRLF_NOTS(1, "tx_dqs:%2d ", tx_dqs * inc_delay);
671c1282
<             PSRAM_TRACENOCRLF_NOTS("  %d ", cali_valid[tx_dqs][rx_dqs]);
---
>             PSRAM_TRACENOCRLF_NOTS(1, "  %d ", cali_valid[tx_dqs][rx_dqs]);
677c1288
<                     if (cali_valid[p][rx_dqs] == 0)
---
>                     if (cali_valid[p][rx_dqs] == false)
686c1297
<                     if (cali_valid[p][rx_dqs] == 0)
---
>                     if (cali_valid[p][rx_dqs] == false)
695c1306
<                     if (cali_valid[tx_dqs][p] == 0)
---
>                     if (cali_valid[tx_dqs][p] == false)
704c1315
<                     if (cali_valid[tx_dqs][p] == 0)
---
>                     if (cali_valid[tx_dqs][p] == false)
712c1323,1511
<         PSRAM_TRACENOCRLF_NOTS("\r\n");
---
>         PSRAM_TRACENOCRLF_NOTS(0, "\r\n");
>     }
>     PSRAM_TRACENOCRLF_NOTS(0, " -------------------------------------------------------------------------- \r\n");
> 
> #ifdef PSRAM_WINDOW_TEST
>     //Processing window data
>     uint8_t cp_volume = volume + 1;
>     uint8_t enable_clear_circle = 0;
>     uint8_t enable_print_window = 0;
>     uint8_t rows;
> 
> #if 1   //Window inner bag 0 test,2021-08-30
>     #define HW_READ_REG(_Reg)           (*((volatile uint32_t*)(_Reg)))
>     #define HW_WRITE_REG(_Reg,_Value)   (*((volatile uint32_t*)(_Reg)) = (uint32_t)(_Value))
>     if (HW_READ_REG(0x400000F4) == 0xCAFE) {
>         HW_WRITE_REG(0x400000F4, 0x9A55);
>         cali_valid[4][4] = 0;//Central point clear
>     }
> #endif
> 
>     for (tx_dqs = 0; tx_dqs < cp_volume; tx_dqs++) {
>         for (rx_dqs = 0; rx_dqs < cp_volume; rx_dqs++) {
>             cali_data[tx_dqs][rx_dqs] = cali_valid[tx_dqs][rx_dqs] + '0';
>         }
>     }
> 
>     if (cp_volume % 2) {
>         rows = cp_volume / 2;
>     } else {
>         rows = cp_volume / 2 - 1;
>     }
>     for (tx_dqs = 0; tx_dqs < rows; tx_dqs++) {
>         //Check the starting line
>         for (rx_dqs = tx_dqs; rx_dqs < cp_volume - tx_dqs; rx_dqs++) {
>             if (cali_data[tx_dqs][rx_dqs] == '0') {
>                 break;
>             }
>         }
> 
>         if (rx_dqs >= cp_volume - tx_dqs) {
>             //Check the end of the line
>             for (rx_dqs = tx_dqs; rx_dqs < cp_volume - tx_dqs; rx_dqs++) {
>                 if (cali_data[volume - tx_dqs][rx_dqs] == '0') {
>                     break;
>                 }
>             }
>             if (rx_dqs >= cp_volume - tx_dqs) {
>                 //Check the starting column
>                 for (rx_dqs = tx_dqs; rx_dqs < cp_volume - tx_dqs; rx_dqs++) {
>                     if (cali_data[rx_dqs][tx_dqs] == '0') {
>                         break;
>                     }
>                 }
>                 if (rx_dqs >= cp_volume - tx_dqs) {
>                     //Check the end of the column
>                     for (rx_dqs = tx_dqs; rx_dqs < cp_volume - tx_dqs; rx_dqs++) {
>                         if (cali_data[rx_dqs][volume - tx_dqs] == '0') {
>                             break;
>                         }
>                     }
>                     if (rx_dqs >= cp_volume - tx_dqs) {
>                         enable_clear_circle = 0;
>                     } else {
>                         enable_clear_circle = 1;
>                     }
>                 } else {
>                     enable_clear_circle = 1;
>                 }
>             } else {
>                 enable_clear_circle = 1;
>             }
>         } else {
>             enable_clear_circle = 1;
>         }
> 
>         //The current line has 0, directly clear the current circle
>         if (enable_clear_circle) {
>             enable_clear_circle = 0;
> 
>             //clear the starting line
>             for (rx_dqs = tx_dqs; rx_dqs < cp_volume - tx_dqs; rx_dqs++) {
>                 cali_data[tx_dqs][rx_dqs] = ' ';
>             }
> 
>             //clear the end of the line
>             for (rx_dqs = tx_dqs; rx_dqs < cp_volume - tx_dqs; rx_dqs++) {
>                 cali_data[volume - tx_dqs][rx_dqs] = ' ';
>             }
> 
>             //clear the starting column
>             for (rx_dqs = tx_dqs + 1; rx_dqs < cp_volume - tx_dqs - 1; rx_dqs++) {
>                 cali_data[rx_dqs][tx_dqs] = ' ';
>             }
> 
>             //clear the end of the column
>             for (rx_dqs = tx_dqs + 1; rx_dqs < cp_volume - tx_dqs - 1; rx_dqs++) {
>                 cali_data[rx_dqs][volume - tx_dqs] = ' ';
>             }
>         } else {
>             //Check if there is 0 in the middle of the ring
>             uint8_t i;
> 
>             enable_print_window = 0;
>             for (i = tx_dqs; i < cp_volume - tx_dqs * 2 + tx_dqs; i++) {
>                 //Check the remaining rows
>                 for (rx_dqs = tx_dqs; rx_dqs < cp_volume - tx_dqs * 2 + tx_dqs; rx_dqs++) {
>                     if (cali_data[i][rx_dqs] == '0') {
>                         break;
>                     }
>                 }
>                 if (rx_dqs < cp_volume - tx_dqs * 2 + tx_dqs) {
>                     enable_print_window = 1;
>                     break;
>                 }
>             }
>             break;
>         }
>     }
> 
>     //Only the middle window is left, print it out forcibly
>     if (tx_dqs >= rows) {
>         enable_print_window = 1;
>     }
> 
>     dqs_point = tx_dqs;
>     dqs_len = cp_volume - tx_dqs * 2;
> 
>     if (last_dqs_point != dqs_point) {
>         last_dqs_point = dqs_point;
> 
>         TRACE_IMM(TR_ATTR_NO_LF | TR_ATTR_NO_TS | TR_ATTR_NO_ID, ", rx_dqs:(%02d,%02d)~(%02d,%02d)",
>                   dqs_point * inc_delay, dqs_point * inc_delay,
>                   (dqs_point + dqs_len - 1)*inc_delay, dqs_point * inc_delay);
>     } else {
>         TRACE_IMM(TR_ATTR_NO_LF | TR_ATTR_NO_TS | TR_ATTR_NO_ID, ", ++++++++++++++++++++++");
>     }
> 
>     if (last_dqs_len != dqs_len) {
>         last_dqs_len = dqs_len;
> 
>         if (enable_print_window) {
>             TRACE_IMM(TR_ATTR_NO_LF | TR_ATTR_NO_TS | TR_ATTR_NO_ID, ", tx_dqs:(%02d,%02d)~(%02d,%02d), abnormal",
>                       dqs_point * inc_delay, dqs_point * inc_delay,
>                       dqs_point * inc_delay, (dqs_point + dqs_len - 1)*inc_delay);
>         } else {
>             TRACE_IMM(TR_ATTR_NO_LF | TR_ATTR_NO_TS | TR_ATTR_NO_ID, ", tx_dqs:(%02d,%02d)~(%02d,%02d), normal",
>                       dqs_point * inc_delay, dqs_point * inc_delay,
>                       dqs_point * inc_delay, (dqs_point + dqs_len - 1)*inc_delay);
>         }
>     } else {
>         if (enable_print_window) {
>             TRACE_IMM(TR_ATTR_NO_LF | TR_ATTR_NO_TS | TR_ATTR_NO_ID, ", ----------------------, abnormal");
>         } else {
>             TRACE_IMM(TR_ATTR_NO_LF | TR_ATTR_NO_TS | TR_ATTR_NO_ID, ", ----------------------, ######");
>         }
>     }
>     TRACE_IMM(TR_ATTR_NO_TS | TR_ATTR_NO_ID, ", vol:%02d, delay:%02d", volume, inc_delay);
> 
>     if (enable_print_window) {
>         enable_print_window = 0;
> 
>         //Print original window data
>         REL_TRACE_NOTS(0, " ");
>         REL_TRACE_NOCRLF_NOTS(0, "   rx_dqs ");
>         for (tx_dqs = 0; tx_dqs <= volume; tx_dqs++) {
>             REL_TRACE_NOCRLF_NOTS(1, " %2d ", tx_dqs * inc_delay);
>         }
>         REL_TRACE_NOCRLF_NOTS(0, "\r\n");
>         for (tx_dqs = 0; tx_dqs <= volume; tx_dqs++) {
>             REL_TRACE_NOCRLF_NOTS(1, "tx_dqs:%2d ", tx_dqs * inc_delay);
>             for (rx_dqs = 0; rx_dqs <= volume; rx_dqs++) {
>                 REL_TRACE_NOCRLF_NOTS(1, "  %d ", cali_valid[tx_dqs][rx_dqs]);
>             }
>             REL_TRACE_NOCRLF_NOTS(0, "\r\n");
>         }
>         REL_TRACE_NOTS(0, " ");
> 
>         //Print new window data
>         REL_TRACE_NOCRLF_NOTS(0, "   rx_dqs ");
>         for (tx_dqs = 0; tx_dqs <= volume; tx_dqs++) {
>             REL_TRACE_NOCRLF_NOTS(1, " %2d ", tx_dqs * inc_delay);
>         }
>         REL_TRACE_NOCRLF_NOTS(0, "\r\n");
>         for (tx_dqs = 0; tx_dqs <= volume; tx_dqs++) {
>             REL_TRACE_NOCRLF_NOTS(1, "tx_dqs:%2d ", tx_dqs * inc_delay);
>             for (rx_dqs = 0; rx_dqs <= volume; rx_dqs++) {
>                 REL_TRACE_NOCRLF_NOTS(1, "  %c ", cali_data[tx_dqs][rx_dqs]);
>             }
>             REL_TRACE_NOCRLF_NOTS(0, "\r\n");
714c1513,1515
<     PSRAM_TRACENOCRLF_NOTS(" -------------------------------------------------------------------------- \r\n");
---
>         REL_TRACE_NOTS(0, " ");
>     }
> #endif
717,718c1518,1520
<     PSRAM_TRACENOCRLF_NOTS("\r\n\r\n ---------------------------------------------------------------------- \r\n");
<     PSRAM_TRACENOCRLF_NOTS("    rx_dqs");
---
>     //Print cali_value window data
>     PSRAM_TRACENOCRLF_NOTS(0, "\r\n\r\n ---------------------------------------------------------------------- \r\n");
>     PSRAM_TRACENOCRLF_NOTS(0, "    rx_dqs");
720c1522
<         PSRAM_TRACENOCRLF_NOTS(" %2d ", tx_dqs*inc_delay);
---
>         PSRAM_TRACENOCRLF_NOTS(1, " %2d ", tx_dqs * inc_delay);
722c1524
<     PSRAM_TRACENOCRLF_NOTS("\r\n");
---
>     PSRAM_TRACENOCRLF_NOTS(0, "\r\n");
724c1526
<         PSRAM_TRACENOCRLF_NOTS("tx_dqs:%2d ", tx_dqs*inc_delay);
---
>         PSRAM_TRACENOCRLF_NOTS(1, "tx_dqs:%2d ", tx_dqs * inc_delay);
726c1528
<             PSRAM_TRACENOCRLF_NOTS("  %d ", cali_value[tx_dqs][rx_dqs]);
---
>             PSRAM_TRACENOCRLF_NOTS(1, "  %d ", cali_value[tx_dqs][rx_dqs]);
728c1530
<         PSRAM_TRACENOCRLF_NOTS("\r\n");
---
>         PSRAM_TRACENOCRLF_NOTS(0, "\r\n");
730c1532
<     PSRAM_TRACENOCRLF_NOTS(" -------------------------------------------------------------------------- \r\n");
---
>     PSRAM_TRACENOCRLF_NOTS(0, " -------------------------------------------------------------------------- \r\n");
743c1545
<     PSRAM_TRACENOCRLF_NOTS("position:%d\r\n", position);
---
>     PSRAM_TRACENOCRLF_NOTS(1, "position:%d\r\n", position);
746,748c1548,1553
<     PSRAM_TRACENOCRLF_NOTS("most optimal position. tx_dqs:%d, rx_dqs:%d\r\n", tx_dqs, rx_dqs);
< 
<     psram_phy->REG_054 = PSRAM_ULP_PHY_REG_PSRAM_TX_CEB_DLY(delay/2) | PSRAM_ULP_PHY_REG_PSRAM_TX_CLK_DLY(delay/2) |
---
>     PSRAM_TRACENOCRLF_NOTS(2, "most optimal position. tx_dqs:%d, rx_dqs:%d\r\n", tx_dqs, rx_dqs);
> #ifdef PSRAM_XCCELA_MODE
>     psram_phy->REG_054 = PSRAM_ULP_PHY_REG_PSRAM_TX_CEB_DLY(tx_ceb) | PSRAM_ULP_PHY_REG_PSRAM_TX_CLK_DLY(tx_dqs) |
>                          PSRAM_ULP_PHY_REG_PSRAM_TX_DQS_DLY(0) | PSRAM_ULP_PHY_REG_PSRAM_RX_DQS_DLY(rx_dqs);
> #else
>     psram_phy->REG_054 = PSRAM_ULP_PHY_REG_PSRAM_TX_CEB_DLY(tx_ceb) | PSRAM_ULP_PHY_REG_PSRAM_TX_CLK_DLY(tx_clk) |
749a1555,1559
> #endif
> 
> #if 0
>     volume = (PSRAM_ULP_PHY_REG_PSRAM_TX_DQS_DLY_MASK >> PSRAM_ULP_PHY_REG_PSRAM_TX_DQS_DLY_SHIFT) / inc_delay;
>     PSRAM_TRACE(2, "volume:%d, inc_delay:%d", volume, inc_delay);
750a1561,1586
>     //calibrate tx_clk
>     PSRAM_TRACE(0, "cali tx_clk");
>     left_bound = -1;
>     right_bound = -1;
>     memset(valid_array, 0, sizeof(valid_array));
>     for (tx_clk = 1; tx_clk <= volume; tx_clk++) {
>         bool valid;
>         //tx_ceb = tx_clk;
>         psram_phy->REG_054 = PSRAM_ULP_PHY_REG_PSRAM_TX_CEB_DLY(tx_ceb * inc_delay) | PSRAM_ULP_PHY_REG_PSRAM_TX_CLK_DLY(tx_clk * inc_delay) |
>                              PSRAM_ULP_PHY_REG_PSRAM_TX_DQS_DLY(delay / 2) | PSRAM_ULP_PHY_REG_PSRAM_RX_DQS_DLY(delay / 2);
>         valid = psramphy_check_write_valid(range);
>         PSRAM_TRACE(3, "tx_clk:0x%x, valid:%d", (tx_clk * inc_delay), valid);
>         valid_array[tx_clk] = valid;
>         if (tx_clk == 1) {
>             if (valid) {
>                 left_bound = tx_clk;
>                 PSRAM_TRACE(1, "left_bound:0x%x", left_bound * inc_delay);
>             }
>         } else if (tx_clk == volume) {
>             if (valid) {
>                 right_bound = tx_clk;//find right bound
>                 PSRAM_TRACE(1, "right_bound:0x%x", right_bound * inc_delay);
>             } else {
>                 if (valid_array[tx_clk - 1]) {
>                     right_bound = tx_clk - 1; //find right bound
>                     PSRAM_TRACE(1, "right_bound:0x%x", right_bound * inc_delay);
752c1588,1610
< static void hal_psram_calib(uint32_t clk)
---
>             }
>         } else {
>             if (valid && !valid_array[tx_clk - 1]) {
>                 left_bound = tx_clk;//find left bound
>                 PSRAM_TRACE(1, "left_bound:0x%x", left_bound * inc_delay);
>             } else if (!valid && valid_array[tx_clk - 1]) {
>                 right_bound = tx_clk - 1; //find right bound
>                 PSRAM_TRACE(1, "right_bound:0x%x", right_bound * inc_delay);
>                 break;
>             }
>         }
>     }
>     if (left_bound != -1 && right_bound != -1) {// && (right_bound-left_bound>1)) {
>         tx_clk = (left_bound + right_bound) / 2;
>         PSRAM_TRACE(3, "cali tx_clk done, tx_clk:0x%x(0x%x-0x%x)", tx_clk * inc_delay, left_bound * inc_delay, right_bound * inc_delay);
>     } else {
>         ASSERT(false, "ERROR, tx_clk need do more cali");
>     }
>     //tx_ceb = tx_clk * inc_delay;
>     tx_clk = tx_clk * inc_delay;
> #endif
> }
> void hal_psram_calib(uint32_t clk)
756c1614
<     PSRAM_TRACE("%s, speed:%d", __func__, clk);
---
>     PSRAM_TRACE(2, "%s, speed:%d", __func__, clk);
765c1623
<         range = 0;
---
>         range = 1;
766a1625,1627
> #ifdef PSRAM_WINDOW_TEST
>     TRACE_IMM(TR_ATTR_NO_LF, "clk:%d, range:%d", clk, range);
> #endif
769,776d1629
< void hal_psram_snoop_enable()
< {
<     psram_mc->REG_044 &= ~PSRAM_ULP_MC_SNP_DISABLE;
< }
< void hal_psram_snoop_disable()
< {
<     psram_mc->REG_044 |= PSRAM_ULP_MC_SNP_DISABLE;
< }
788a1642
> #ifndef FPGA
790c1644,1646
<     hal_sys_timer_delay_us(30);
---
>     hal_sys_timer_delay_us(100);
> #endif
>     hal_psram_digphy_init();
791a1648,1650
> #if !defined(FPGA) && !defined(SIMU)
>     hal_psram_init_calib();
> #endif
809a1669
> #if !defined(FPGA) && !defined(SIMU)
810a1671
> #endif
