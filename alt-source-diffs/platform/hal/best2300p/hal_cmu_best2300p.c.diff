local: https://raw.githubusercontent.com/pine64/OpenPineBuds/533d01aee617f24dfe9cda124fbb20b6efbe2f73/platform/hal/best2300p/hal_cmu_best2300p.c
remote: https://raw.githubusercontent.com/OneDeuxTriSeiGo/device_soc_bestechnic/c0502a1345f2f5b7ffc7f38b5374be0fcb42a487/bes2600/liteos_m/sdk/bsp/platform/hal/best2003/hal_cmu_best2003.c
diff -sw local remote
---

1c1,5
< /***************************************************************************
---
> /*
>  * Copyright (c) 2021 Bestechnic (Shanghai) Co., Ltd. All rights reserved.
>  * Licensed under the Apache License, Version 2.0 (the "License");
>  * you may not use this file except in compliance with the License.
>  * You may obtain a copy of the License at
3,4c7
<  * Copyright 2015-2019 BES.
<  * All rights reserved. All unpublished rights reserved.
---
>  *     http://www.apache.org/licenses/LICENSE-2.0
6,15c9,14
<  * No part of this work may be used or reproduced in any form or by any
<  * means, or stored in a database or retrieval system, without prior written
<  * permission of BES.
<  *
<  * Use of this work is governed by a license granted by BES.
<  * This work contains confidential and proprietary information of
<  * BES. which is protected by copyright, trade secret,
<  * trademark and other intellectual property rights.
<  *
<  ****************************************************************************/
---
>  * Unless required by applicable law or agreed to in writing, software
>  * distributed under the License is distributed on an "AS IS" BASIS,
>  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
>  * See the License for the specific language governing permissions and
>  * limitations under the License.
>  */
19a19
> #include CHIP_SPECIFIC_HDR(reg_wfcmu)
27c27
< #include "hal_sleep_core_pd.h"
---
> #include "hal_sec.h"
32a33
> #include "analog.h"
33a35,41
> #include "hal_psram.h"
> #include "hal_psramuhs.h"
> #include "hal_norflash.h"
> #include "hal_wdt.h"
> #include "tgt_hardware.h"
> #include "hal_dma.h"
> #include CHIP_SPECIFIC_HDR(hal_dmacfg)
35,37c43,44
< #ifdef USB_HIGH_SPEED
< #ifndef USB_USE_USBPLL
< #define USB_USE_USBPLL
---
> #ifdef FLASH_SUSPEND
> #include "norflash_api.h"
39,41d45
< #endif
< 
< #define CODEC_CLK_FROM_ANA
48a53,54
> #define HAL_CMU_PWM_SLOW_CLOCK          (32 * 1000)
> 
50c56
< #define HAL_CMU_26M_READY_TIMEOUT       MS_TO_TICKS(4)
---
> #define HAL_CMU_26M_READY_TIMEOUT       MS_TO_TICKS(3)
53,58d58
< #ifdef CORE_SLEEP_POWER_DOWN
< #define TIMER1_SEL_LOC                  BOOT_TEXT_SRAM_LOC
< #else
< #define TIMER1_SEL_LOC                  BOOT_TEXT_FLASH_LOC
< #endif
< 
60,67c60,62
<     CMU_USB_CLK_SRC_PLL_60M         = 0,
<     CMU_USB_CLK_SRC_PLL_60M_ALT     = 1,
<     CMU_USB_CLK_SRC_PLL_48M         = 2,
<     CMU_USB_CLK_SRC_TS              = 3,
<     CMU_USB_CLK_SRC_OSC_48M         = 4,
<     CMU_USB_CLK_SRC_OSC_24M_X2      = 5,
<     CMU_USB_CLK_SRC_OSC_26M_X4      = 6,
<     CMU_USB_CLK_SRC_OSC_26M_X2      = 7,
---
>     CMU_USB_CLK_SRC_PLL_48M         = 0,
>     CMU_USB_CLK_SRC_PLL_60M         = 1,
>     CMU_USB_CLK_SRC_OSC_24M_X2      = 2,
86a82,124
> enum CMU_DMA_REQ_T {
>     CMU_DMA_REQ_CODEC_RX            = 0,
>     CMU_DMA_REQ_CODEC_TX            = 1,
>     CMU_DMA_REQ_DSD_RX              = 2,
>     CMU_DMA_REQ_DSD_TX              = 3,
>     CMU_DMA_REQ_IR_RX               = 6,
>     CMU_DMA_REQ_IR_TX               = 7,
>     CMU_DMA_REQ_FLS1                = 8,
>     CMU_DMA_REQ_FLS0                = 10,
>     CMU_DMA_REQ_BTDUMP              = 12,
>     CMU_DMA_REQ_SDEMMC              = 13,
>     CMU_DMA_REQ_I2C0_RX             = 14,
>     CMU_DMA_REQ_I2C0_TX             = 15,
>     CMU_DMA_REQ_I2C1_RX             = 16,
>     CMU_DMA_REQ_I2C1_TX             = 17,
>     CMU_DMA_REQ_SPILCD0_RX          = 18,
>     CMU_DMA_REQ_SPILCD0_TX          = 19,
>     CMU_DMA_REQ_SPILCD1_RX          = 20,
>     CMU_DMA_REQ_SPILCD1_TX          = 21,
>     CMU_DMA_REQ_SPI_ITN_RX          = 22,
>     CMU_DMA_REQ_SPI_ITN_TX          = 23,
>     CMU_DMA_REQ_UART0_RX            = 24,
>     CMU_DMA_REQ_UART0_TX            = 25,
>     CMU_DMA_REQ_UART1_RX            = 26,
>     CMU_DMA_REQ_UART1_TX            = 27,
>     CMU_DMA_REQ_UART2_RX            = 28,
>     CMU_DMA_REQ_UART2_TX            = 29,
>     CMU_DMA_REQ_PCM_RX              = 30,
>     CMU_DMA_REQ_PCM_TX              = 31,
>     CMU_DMA_REQ_I2S0_RX             = 32,
>     CMU_DMA_REQ_I2S0_TX             = 33,
>     CMU_DMA_REQ_SPDIF0_RX           = 34,
>     CMU_DMA_REQ_SPDIF0_TX           = 35,
>     CMU_DMA_REQ_I2C2_RX             = 36,
>     CMU_DMA_REQ_I2C2_TX             = 37,
>     CMU_DMA_REQ_UART3_RX            = 38,
>     CMU_DMA_REQ_UART3_TX            = 39,
>     CMU_DMA_REQ_I2S1_RX             = 40,
>     CMU_DMA_REQ_I2S1_TX             = 41,
> 
>     CMU_DMA_REQ_NULL                = 5,
> };
> 
90d127
<     __IO uint32_t entry;
99,108c136
< static struct CP_STARTUP_CFG_T * const cp_cfg = (struct CP_STARTUP_CFG_T *)0x200F7FE0;
< 
< #define HAL_CMU_PLL_USB_HS              HAL_CMU_PLL_QTY
< #ifdef USB_USE_USBPLL
< #define PLL_USER_MAP_NUM                (HAL_CMU_PLL_QTY + 1)
< #else
< #define PLL_USER_MAP_NUM                HAL_CMU_PLL_QTY
< #endif
< static uint8_t BOOT_BSS_LOC pll_user_map[PLL_USER_MAP_NUM];
< STATIC_ASSERT(HAL_CMU_PLL_USER_QTY <= sizeof(pll_user_map[0]) * 8, "Too many PLL users");
---
> static struct WLANCMU_T * const POSSIBLY_UNUSED wlancmu = (struct WLANCMU_T *)WIFI_CMU_BASE;
110,112c138
< #ifdef ROM_BUILD
< static enum HAL_CMU_USB_CLOCK_SEL_T usb_clk_sel;
< #endif
---
> static uint32_t cp_entry;
114c140,141
< static bool anc_enabled;
---
> static uint8_t BOOT_BSS_LOC pll_user_map[HAL_CMU_PLL_QTY];
> STATIC_ASSERT(HAL_CMU_PLL_USER_QTY <= sizeof(pll_user_map[0]) * 8, "Too many PLL users");
123a151,154
> #ifdef ANA_26M_X4_ENABLE
> #error "CHIP_BEST2003 don't support X4"
> #endif
> 
125,126c156
< static enum HAL_CMU_LOW_SYS_FREQ_T BOOT_BSS_LOC low_sys_freq;
< static bool BOOT_BSS_LOC low_sys_freq_en;
---
> static enum HAL_CMU_FREQ_T BOOT_BSS_LOC cmu_sys_freq;
160c190
<     if (id >= HAL_CMU_AON_MCU) {
---
>     if (id >= HAL_CMU_AON_A7) {
168c198
<     } else if (id < HAL_CMU_AON_A_CMU) {
---
>     } else if (id < HAL_CMU_MOD_Q_NULL) {
169a200,201
>     } else if (id < HAL_CMU_AON_A_CMU) {
>         cmu->QCLK_ENABLE = (1 << (id - HAL_CMU_MOD_Q_NULL));
180c212
<     if (id >= HAL_CMU_AON_MCU) {
---
>     if (id >= HAL_CMU_AON_A7) {
183a216,218
>     if (id == HAL_CMU_MOD_P_TZC)
>         return 0;
> 
188c223
<     } else if (id < HAL_CMU_AON_A_CMU) {
---
>     } else if (id < HAL_CMU_MOD_Q_NULL) {
189a225,226
>     } else if (id < HAL_CMU_AON_A_CMU) {
>         cmu->QCLK_DISABLE = (1 << (id - HAL_CMU_MOD_Q_NULL));
201c238
<     if (id >= HAL_CMU_AON_MCU) {
---
>     if (id >= HAL_CMU_AON_A7) {
209c246
<     } else if (id < HAL_CMU_AON_A_CMU) {
---
>     } else if (id < HAL_CMU_MOD_Q_NULL) {
210a248,249
>     } else if (id < HAL_CMU_AON_A_CMU) {
>         status = cmu->QCLK_ENABLE & (1 << (id - HAL_CMU_MOD_Q_NULL));
224c263
<     if (id >= HAL_CMU_AON_MCU) {
---
>     if (id >= HAL_CMU_AON_A7) {
234c273
<     } else if (id < HAL_CMU_AON_A_CMU) {
---
>     } else if (id < HAL_CMU_MOD_Q_NULL) {
236a276,278
>     } else if (id < HAL_CMU_AON_A_CMU) {
>         reg = &cmu->QCLK_MODE;
>         val = (1 << (id - HAL_CMU_MOD_Q_NULL));
257c299
<     if (id >= HAL_CMU_AON_MCU) {
---
>     if (id >= HAL_CMU_AON_A7) {
265c307
<     } else if (id < HAL_CMU_AON_A_CMU) {
---
>     } else if (id < HAL_CMU_MOD_Q_NULL) {
266a309,310
>     } else if (id < HAL_CMU_AON_A_CMU) {
>         mode = cmu->QCLK_MODE & (1 << (id - HAL_CMU_MOD_Q_NULL));
279a324,326
>     if (id == HAL_CMU_MOD_P_TZC)
>         return 0;
> 
284c331
<     } else if (id < HAL_CMU_AON_A_CMU) {
---
>     } else if (id < HAL_CMU_MOD_Q_NULL) {
286c333,335
<     } else {
---
>     } else if (id < HAL_CMU_AON_A_CMU) {
>         cmu->QRESET_SET = (1 << (id - HAL_CMU_MOD_Q_NULL));
>     } else if (id < HAL_CMU_AON_A7) {
287a337,338
>     } else {
>         aoncmu->SOFT_RSTN_SET = (1 << (id - HAL_CMU_AON_A7));
301c352,353
<         asm volatile("nop; nop;");
---
>         asm volatile("nop; nop; nop; nop; nop; nop; nop; nop;");
>         asm volatile("nop; nop; nop; nop;");
303a356
>         asm volatile("nop; nop; nop; nop; nop; nop; nop; nop;");
305c358
<     } else if (id < HAL_CMU_AON_A_CMU) {
---
>     } else if (id < HAL_CMU_MOD_Q_NULL) {
307c360,366
<     } else {
---
>         asm volatile("nop; nop; nop; nop; nop; nop; nop; nop;");
>         asm volatile("nop; nop; nop; nop;");
>     } else if (id < HAL_CMU_AON_A_CMU) {
>         cmu->QRESET_CLR = (1 << (id - HAL_CMU_MOD_Q_NULL));
>         asm volatile("nop; nop; nop; nop; nop; nop; nop; nop;");
>         asm volatile("nop; nop; nop; nop;");
>     } else if (id < HAL_CMU_AON_A7) {
309a369,371
>     } else {
>         aoncmu->SOFT_RSTN_CLR = (1 << (id - HAL_CMU_AON_A7));
>         aocmu_reg_update_wait();
327c389
<     } else if (id < HAL_CMU_AON_A_CMU) {
---
>     } else if (id < HAL_CMU_MOD_Q_NULL) {
329c391,393
<     } else {
---
>     } else if (id < HAL_CMU_AON_A_CMU) {
>         status = cmu->QRESET_SET & (1 << (id - HAL_CMU_MOD_Q_NULL));
>     } else if (id < HAL_CMU_AON_A7) {
330a395,396
>     } else {
>         status = aoncmu->SOFT_RSTN_SET & (1 << (id - HAL_CMU_AON_A7));
352c418
<     } else if (id < HAL_CMU_AON_A_CMU) {
---
>     } else if (id < HAL_CMU_MOD_Q_NULL) {
354c420,422
<     } else {
---
>     } else if (id < HAL_CMU_AON_A_CMU) {
>         cmu->QRESET_PULSE = (1 << (id - HAL_CMU_MOD_Q_NULL));
>     } else if (id < HAL_CMU_AON_A7) {
361a430,437
>     } else {
>         aoncmu->SOFT_RSTN_PULSE = (1 << (id - HAL_CMU_AON_A7));
>         // Total 3 CLK-26M cycles needed
>         // AOCMU runs in 26M clock domain and its read operations consume at least 1 26M-clock cycle.
>         // (Whereas its write operations will finish at 1 HCLK cycle -- finish once in async bridge fifo)
>         aoncmu->CHIP_ID;
>         aoncmu->CHIP_ID;
>         aoncmu->CHIP_ID;
401c477
< void BOOT_TEXT_FLASH_LOC hal_cmu_timer0_select_fast(void)
---
> void hal_cmu_timer0_select_fast(void)
409c485
<     aoncmu->CLK_SELECT |= AON_CMU_SEL_TIMER_FAST;
---
>     aoncmu->TIMER_CLK |= AON_CMU_SEL_TIMER_FAST;
421c497
<     aoncmu->CLK_SELECT &= ~AON_CMU_SEL_TIMER_FAST;
---
>     aoncmu->TIMER_CLK &= ~AON_CMU_SEL_TIMER_FAST;
425c501
< void TIMER1_SEL_LOC hal_cmu_timer1_select_fast(void)
---
> void BOOT_TEXT_FLASH_LOC hal_cmu_timer1_select_fast(void)
435c511
< void TIMER1_SEL_LOC hal_cmu_timer1_select_slow(void)
---
> void BOOT_TEXT_FLASH_LOC hal_cmu_timer1_select_slow(void)
464a541,580
> void hal_cmu_dsp_timer0_select_fast(void)
> {
>     uint32_t lock;
> 
>     lock = int_lock();
>     // 6.5M
>     cmu->DSP_DIV |= (1 << CMU_SEL_TIMER_FAST_AP_SHIFT);
>     int_unlock(lock);
> }
> 
> void hal_cmu_dsp_timer0_select_slow(void)
> {
>     uint32_t lock;
> 
>     lock = int_lock();
>     // 16K
>     cmu->DSP_DIV &= ~(1 << CMU_SEL_TIMER_FAST_AP_SHIFT);
>     int_unlock(lock);
> }
> 
> void hal_cmu_dsp_timer1_select_fast(void)
> {
>     uint32_t lock;
> 
>     lock = int_lock();
>     // 6.5M
>     cmu->DSP_DIV |= (1 << (CMU_SEL_TIMER_FAST_AP_SHIFT + 1));
>     int_unlock(lock);
> }
> 
> void hal_cmu_dsp_timer1_select_slow(void)
> {
>     uint32_t lock;
> 
>     lock = int_lock();
>     // 16K
>     cmu->DSP_DIV &= ~(1 << (CMU_SEL_TIMER_FAST_AP_SHIFT + 1));
>     int_unlock(lock);
> }
> 
482,484c598,603
< #ifdef OSC_26M_X4_AUD2BB
< 
< // Any of 78M/104M/208M is changed to 26M x4 (104M)
---
> int BOOT_TEXT_SRAM_LOC hal_cmu_flash_set_freq(enum HAL_CMU_FREQ_T freq)
> {
>     uint32_t set;
>     uint32_t clr;
>     uint32_t lock;
>     bool clk_en;
486,526c605,609
< #define SYS_SET_FREQ_FUNC(f, F, CLK_OV) \
< int hal_cmu_ ##f## _set_freq(enum HAL_CMU_FREQ_T freq) \
< { \
<     uint32_t enable; \
<     uint32_t disable; \
<     if (freq >= HAL_CMU_FREQ_QTY) { \
<         return 1; \
<     } \
<     if (freq == HAL_CMU_FREQ_32K) { \
<         enable = 0; \
<         disable = CMU_SEL_OSC_ ##F## _DISABLE | CMU_SEL_OSCX2_ ##F## _DISABLE | \
<             CMU_SEL_PLL_ ##F## _DISABLE | CMU_RSTN_DIV_ ##F## _DISABLE | CMU_BYPASS_DIV_ ##F## _DISABLE; \
<     } else if (freq == HAL_CMU_FREQ_26M) { \
<         enable = CMU_SEL_OSC_ ##F## _ENABLE; \
<         disable = CMU_SEL_OSCX2_ ##F## _DISABLE | \
<             CMU_SEL_PLL_ ##F## _DISABLE | CMU_RSTN_DIV_ ##F## _DISABLE | CMU_BYPASS_DIV_ ##F## _DISABLE; \
<     } else if (freq == HAL_CMU_FREQ_52M) { \
<         enable = CMU_SEL_OSCX2_ ##F## _ENABLE; \
<         disable = CMU_SEL_PLL_ ##F## _DISABLE | CMU_RSTN_DIV_ ##F## _DISABLE | CMU_BYPASS_DIV_ ##F## _DISABLE; \
<     } else { \
<         enable = CMU_SEL_PLL_ ##F## _ENABLE | CMU_BYPASS_DIV_ ##F## _ENABLE; \
<         disable = CMU_RSTN_DIV_ ##F## _DISABLE; \
<     } \
<     if (enable & CMU_SEL_PLL_ ##F## _ENABLE) { \
<         CLK_OV; \
<         cmu->SYS_CLK_ENABLE = CMU_RSTN_DIV_ ##F## _ENABLE; \
<         if (enable & CMU_BYPASS_DIV_ ##F## _ENABLE) { \
<             cmu->SYS_CLK_ENABLE = CMU_BYPASS_DIV_ ##F## _ENABLE; \
<         } else { \
<             cmu->SYS_CLK_DISABLE = CMU_BYPASS_DIV_ ##F## _DISABLE; \
<         } \
<     } \
<     cmu->SYS_CLK_ENABLE = enable; \
<     if (enable & CMU_SEL_PLL_ ##F## _ENABLE) { \
<         cmu->SYS_CLK_DISABLE = disable; \
<     } else { \
<         cmu->SYS_CLK_DISABLE = disable & ~(CMU_RSTN_DIV_ ##F## _DISABLE | CMU_BYPASS_DIV_ ##F## _DISABLE); \
<         cmu->SYS_CLK_DISABLE = CMU_BYPASS_DIV_ ##F## _DISABLE; \
<         cmu->SYS_CLK_DISABLE = CMU_RSTN_DIV_ ##F## _DISABLE; \
<     } \
<     return 0; \
---
>     if (freq >= HAL_CMU_FREQ_QTY) {
>         return 1;
>     }
>     if (freq == HAL_CMU_FREQ_32K) {
>         return 2;
529c612,652
< #else // !OSC_26M_X4_AUD2BB
---
>     switch (freq) {
>     case HAL_CMU_FREQ_26M:
>         set = 0;
>         clr = AON_CMU_RSTN_DIV_FLS | AON_CMU_BYPASS_DIV_FLS | AON_CMU_SEL_FLS_OSCX2 | AON_CMU_SEL_FLS_OSCX4 | AON_CMU_SEL_FLS_PLL;
>         break;
>     case HAL_CMU_FREQ_52M:
>         set = AON_CMU_SEL_FLS_OSCX2;
>         clr = AON_CMU_RSTN_DIV_FLS | AON_CMU_BYPASS_DIV_FLS | AON_CMU_SEL_FLS_OSCX4 | AON_CMU_SEL_FLS_PLL;
>         break;
>     case HAL_CMU_FREQ_78M:
>     case HAL_CMU_FREQ_104M:
> #ifdef OSC_26M_X4_AUD2BB
>         set = AON_CMU_SEL_FLS_OSCX4;
>         clr = AON_CMU_RSTN_DIV_FLS | AON_CMU_BYPASS_DIV_FLS | AON_CMU_SEL_FLS_OSCX2 | AON_CMU_SEL_FLS_PLL;
>         break;
> #endif
>     case HAL_CMU_FREQ_156M:
>     case HAL_CMU_FREQ_208M:
>     case HAL_CMU_FREQ_260M:
>         set = AON_CMU_RSTN_DIV_FLS | AON_CMU_SEL_FLS_PLL;
>         clr = AON_CMU_CFG_DIV_FLS_MASK | AON_CMU_BYPASS_DIV_FLS | AON_CMU_SEL_FLS_OSCX2 | AON_CMU_SEL_FLS_OSCX4;
>         if (0) {
> #ifndef OSC_26M_X4_AUD2BB
>         } else if (freq <= HAL_CMU_FREQ_78M) {
>             set |= AON_CMU_CFG_DIV_FLS(3);
>         } else if (freq <= HAL_CMU_FREQ_104M) {
>             set |= AON_CMU_CFG_DIV_FLS(2);
> #endif
>         } else if (freq <= HAL_CMU_FREQ_156M) {
>             set |= AON_CMU_CFG_DIV_FLS(1);
>         } else { // 208M or 260M
>             set |= AON_CMU_CFG_DIV_FLS(0);
>         }
>         break;
>     case HAL_CMU_FREQ_390M:
>     case HAL_CMU_FREQ_780M:
>     default:
>         set = AON_CMU_BYPASS_DIV_FLS | AON_CMU_SEL_FLS_PLL;
>         clr = AON_CMU_RSTN_DIV_FLS | AON_CMU_SEL_FLS_OSCX2 | AON_CMU_SEL_FLS_OSCX4;
>         break;
>     };
531,586c654,666
< #define SYS_SET_FREQ_FUNC(f, F, CLK_OV) \
< int hal_cmu_ ##f## _set_freq(enum HAL_CMU_FREQ_T freq) \
< { \
<     uint32_t lock; \
<     uint32_t enable; \
<     uint32_t disable; \
<     int div = -1; \
<     if (freq >= HAL_CMU_FREQ_QTY) { \
<         return 1; \
<     } \
<     if (freq == HAL_CMU_FREQ_32K) { \
<         enable = 0; \
<         disable = CMU_SEL_OSC_ ##F## _DISABLE | CMU_SEL_OSCX2_ ##F## _DISABLE | \
<             CMU_SEL_PLL_ ##F## _DISABLE | CMU_RSTN_DIV_ ##F## _DISABLE | CMU_BYPASS_DIV_ ##F## _DISABLE; \
<     } else if (freq == HAL_CMU_FREQ_26M) { \
<         enable = CMU_SEL_OSC_ ##F## _ENABLE; \
<         disable = CMU_SEL_OSCX2_ ##F## _DISABLE | \
<             CMU_SEL_PLL_ ##F## _DISABLE | CMU_RSTN_DIV_ ##F## _DISABLE | CMU_BYPASS_DIV_ ##F## _DISABLE; \
<     } else if (freq == HAL_CMU_FREQ_52M) { \
<         enable = CMU_SEL_OSCX2_ ##F## _ENABLE; \
<         disable = CMU_SEL_PLL_ ##F## _DISABLE | CMU_RSTN_DIV_ ##F## _DISABLE | CMU_BYPASS_DIV_ ##F## _DISABLE; \
<     } else if (freq == HAL_CMU_FREQ_78M) { \
<         enable = CMU_SEL_PLL_ ##F## _ENABLE | CMU_RSTN_DIV_ ##F## _ENABLE; \
<         disable = CMU_BYPASS_DIV_ ##F## _DISABLE; \
<         div = 1; \
<     } else if (freq == HAL_CMU_FREQ_104M) { \
<         enable = CMU_SEL_PLL_ ##F## _ENABLE | CMU_RSTN_DIV_ ##F## _ENABLE; \
<         disable = CMU_BYPASS_DIV_ ##F## _DISABLE; \
<         div = 0; \
<     } else { \
<         enable = CMU_SEL_PLL_ ##F## _ENABLE | CMU_BYPASS_DIV_ ##F## _ENABLE; \
<         disable = CMU_RSTN_DIV_ ##F## _DISABLE; \
<     } \
<     if (div >= 0) { \
<         CLK_OV; \
<         lock = int_lock(); \
<         cmu->SYS_DIV = SET_BITFIELD(cmu->SYS_DIV, CMU_CFG_DIV_ ##F, div); \
<         int_unlock(lock); \
<     } \
<     if (enable & CMU_SEL_PLL_ ##F## _ENABLE) { \
<         cmu->SYS_CLK_ENABLE = CMU_RSTN_DIV_ ##F## _ENABLE; \
<         if (enable & CMU_BYPASS_DIV_ ##F## _ENABLE) { \
<             cmu->SYS_CLK_ENABLE = CMU_BYPASS_DIV_ ##F## _ENABLE; \
<         } else { \
<             cmu->SYS_CLK_DISABLE = CMU_BYPASS_DIV_ ##F## _DISABLE; \
<         } \
<     } \
<     cmu->SYS_CLK_ENABLE = enable; \
<     if (enable & CMU_SEL_PLL_ ##F## _ENABLE) { \
<         cmu->SYS_CLK_DISABLE = disable; \
<     } else { \
<         cmu->SYS_CLK_DISABLE = disable & ~(CMU_RSTN_DIV_ ##F## _DISABLE | CMU_BYPASS_DIV_ ##F## _DISABLE); \
<         cmu->SYS_CLK_DISABLE = CMU_BYPASS_DIV_ ##F## _DISABLE; \
<         cmu->SYS_CLK_DISABLE = CMU_RSTN_DIV_ ##F## _DISABLE; \
<     } \
<     return 0; \
---
>     lock = int_lock();
>     clk_en = !!(cmu->OCLK_DISABLE & SYS_OCLK_FLASH);
>     if (clk_en) {
>         cmu->OCLK_DISABLE = SYS_OCLK_FLASH;
>         cmu->HCLK_DISABLE = SYS_HCLK_FLASH;
>         // Wait at least 2 cycles of flash controller. The min freq is 26M, the same as AON.
>         aocmu_reg_update_wait();
>         aocmu_reg_update_wait();
>     }
>     aoncmu->FLS_PSR_CLK = (aoncmu->FLS_PSR_CLK & ~clr) | set;
>     if (clk_en) {
>         cmu->HCLK_ENABLE = SYS_HCLK_FLASH;
>         cmu->OCLK_ENABLE = SYS_OCLK_FLASH;
587a668
>     int_unlock(lock);
589c670,671
< #endif // !OSC_26M_X4_AUD2BB
---
>     return 0;
> }
591,594c673,678
< #ifdef MCU_SYS_CLOCK_400M
< #define FLASH_DIV_OFFSET                2
< #elif defined(MCU_SYS_CLOCK_300M)
< #define FLASH_DIV_OFFSET                1
---
> int BOOT_TEXT_SRAM_LOC hal_cmu_flash1_set_freq(enum HAL_CMU_FREQ_T freq)
> {
>     aoncmu->FLASH_IOCFG |= AON_CMU_PU_FLASH1_IO;
>     //TODO: 2003 flash0 and flash1 use same clock source, so don't change clk freq in case of flash0 error
> #ifdef ROM_BUILD //2003 rom only use one flash
>     return hal_cmu_flash_set_freq(freq);
596c680
< #define FLASH_DIV_OFFSET                0
---
>     return 0;
597a682,696
> }
> 
> int hal_cmu_mem_set_freq(enum HAL_CMU_FREQ_T freq)
> {
>     uint32_t set;
>     uint32_t clr;
>     uint32_t lock;
>     bool clk_en;
> 
>     if (freq >= HAL_CMU_FREQ_QTY) {
>         return 1;
>     }
>     if (freq == HAL_CMU_FREQ_32K) {
>         return 2;
>     }
598a698,709
>     // 2003 psram ctrl use 400M clk from bbpsram
>     switch (freq) {
>     case HAL_CMU_FREQ_26M:
>         set = 0;
>         clr = AON_CMU_RSTN_DIV_PSR | AON_CMU_BYPASS_DIV_PSR | AON_CMU_SEL_PSR_OSCX2 | AON_CMU_SEL_PSR_OSCX4 | AON_CMU_SEL_PSR_PLL;
>         break;
>     case HAL_CMU_FREQ_52M:
>         set = AON_CMU_SEL_PSR_OSCX2;
>         clr = AON_CMU_RSTN_DIV_PSR | AON_CMU_BYPASS_DIV_PSR | AON_CMU_SEL_PSR_OSCX4 | AON_CMU_SEL_PSR_PLL;
>         break;
>     case HAL_CMU_FREQ_78M:
>     case HAL_CMU_FREQ_104M:
600,602c711,713
< #define FLASH_FREQ_OV                   { aoncmu->CLK_OUT |= AON_CMU_SEL_X4_FLS; }
< #else
< #define FLASH_FREQ_OV                   { div += FLASH_DIV_OFFSET; }
---
>         set = AON_CMU_SEL_PSR_OSCX4;
>         clr = AON_CMU_RSTN_DIV_PSR | AON_CMU_BYPASS_DIV_PSR | AON_CMU_SEL_PSR_OSCX2 | AON_CMU_SEL_PSR_PLL;
>         break;
603a715,757
>     case HAL_CMU_FREQ_156M:
>     case HAL_CMU_FREQ_208M:
>     case HAL_CMU_FREQ_260M:
>         set = AON_CMU_RSTN_DIV_PSR | AON_CMU_SEL_PSR_PLL | AON_CMU_SEL_PSR_INT;
>         clr = AON_CMU_CFG_DIV_PSR_MASK | AON_CMU_BYPASS_DIV_PSR | AON_CMU_SEL_PSR_OSCX2 | AON_CMU_SEL_PSR_OSCX4;
>         if (0) {
> #ifndef OSC_26M_X4_AUD2BB
>         } else if (freq <= HAL_CMU_FREQ_78M) {
>             set |= AON_CMU_CFG_DIV_PSR(3);
>         } else if (freq <= HAL_CMU_FREQ_104M) {
>             set |= AON_CMU_CFG_DIV_PSR(2);
> #endif
>         } else if (freq <= HAL_CMU_FREQ_156M) {
>             set |= AON_CMU_CFG_DIV_PSR(1);
>         } else { // 208M or 260M
>             set |= AON_CMU_CFG_DIV_PSR(0);
>         }
>         break;
>     case HAL_CMU_FREQ_390M:
>     case HAL_CMU_FREQ_780M:
>     default:
>         set = AON_CMU_BYPASS_DIV_PSR | AON_CMU_SEL_PSR_PLL | AON_CMU_SEL_PSR_INT;
>         clr = AON_CMU_RSTN_DIV_PSR | AON_CMU_SEL_PSR_OSCX2 | AON_CMU_SEL_PSR_OSCX4;
>         break;
>     };
> 
>     lock = int_lock();
>     clk_en = !!(cmu->OCLK_DISABLE & SYS_OCLK_PSRAM200);
>     if (clk_en) {
>         aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_TOP_PHY_PS_DISABLE;
>         cmu->OCLK_DISABLE = SYS_OCLK_PSRAM200;
>         cmu->HCLK_DISABLE = SYS_HCLK_PSRAM200;
>         // Wait at least 2 cycles of psram controller. The min freq is 26M, the same as AON.
>         aocmu_reg_update_wait();
>         aocmu_reg_update_wait();
>     }
>     aoncmu->FLS_PSR_CLK = (aoncmu->FLS_PSR_CLK & ~clr) | set;
>     aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_TOP_PHY_PS_ENABLE;
>     if (clk_en) {
>         cmu->HCLK_ENABLE = SYS_HCLK_PSRAM200;
>         cmu->OCLK_ENABLE = SYS_OCLK_PSRAM200;
>     }
>     int_unlock(lock);
605c759,760
< BOOT_TEXT_SRAM_LOC SYS_SET_FREQ_FUNC(flash, FLS, FLASH_FREQ_OV);
---
>     return 0;
> }
607,608c762
< #ifdef LOW_SYS_FREQ
< void hal_cmu_low_sys_clock_set(enum HAL_CMU_LOW_SYS_FREQ_T freq)
---
> int hal_cmu_ddr_clock_enable()
609a764,765
>     uint32_t set;
>     uint32_t clr;
610a767
>     bool clk_en;
612,613c769,793
<     if (hal_get_chip_metal_id() == HAL_CHIP_METAL_ID_0) {
<         return;
---
>     hal_cmu_pll_enable(HAL_CMU_PLL_DDR, HAL_CMU_PLL_USER_PSRAM);
> #if 1
>     //pxclk use xclk, works in synchronous mode
>     //a7 can change sys freq in this mode
>     cmu->PERIPH_CLK &= ~CMU_SEL_PSRAMX2;
>     *(volatile uint32_t *)(GPV_PSRAM1G_BASE+0x42020) = 0;
> #else
>     //pxclk use psram2, works in asynchronous mode
>     *(volatile uint32_t *)(GPV_PSRAM1G_BASE+0x42020) = 4;
>     cmu->PERIPH_CLK |= CMU_SEL_PSRAMX2;
>     aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_PSRAMX2_ENABLE;
> #endif
> 
>     // PSRAMUHS can't use ddr pll divider
>     set = AON_CMU_BYPASS_DIV_DDR | AON_CMU_SEL_DDR_PLL | AON_CMU_CFG_DIV_PSRAMX2(2);
>     clr = AON_CMU_RSTN_DIV_DDR | AON_CMU_SEL_DDR_OSCX2 | AON_CMU_SEL_DDR_OSCX4 | AON_CMU_CFG_DIV_PSRAMX2_MASK;
> 
>     lock = int_lock();
>     clk_en = !!(cmu->OCLK_DISABLE & SYS_OCLK_PSRAM1G);
>     if (clk_en) {
>         cmu->OCLK_DISABLE = SYS_OCLK_PSRAM1G;
>         cmu->HCLK_DISABLE = SYS_HCLK_PSRAM1G;
>         // Wait at least 2 cycles of psram controller. The min freq is 26M, the same as AON.
>         aocmu_reg_update_wait();
>         aocmu_reg_update_wait();
614a795,799
>     aoncmu->DDR_CLK = (aoncmu->DDR_CLK & ~clr) | set;
> 
>     cmu->XCLK_ENABLE = SYS_XCLK_PSRAM1G | SYS_XCLK_PSRAM1GMX | SYS_XCLK_GPV_PSRAM1G;
>     cmu->HCLK_ENABLE = SYS_HCLK_PSRAM1G;
>     cmu->OCLK_ENABLE = SYS_OCLK_PSRAM1G;
616,618d800
<     lock = int_lock();
<     low_sys_freq = freq;
<     hal_cmu_sys_set_freq(hal_sysfreq_get_hw_freq());
619a802,803
> 
>     return 0;
622c806
< int hal_cmu_fast_timer_offline(void)
---
> void hal_cmu_ddr_clock_disable()
624c808,811
<     return low_sys_freq_en && low_sys_freq != HAL_CMU_LOW_SYS_FREQ_13M;
---
>     cmu->XCLK_DISABLE = SYS_XCLK_PSRAM1G | SYS_XCLK_PSRAM1GMX | SYS_XCLK_GPV_PSRAM1G;
>     cmu->OCLK_DISABLE = SYS_OCLK_PSRAM1G;
>     cmu->HCLK_DISABLE = SYS_HCLK_PSRAM1G;
>     hal_cmu_pll_disable(HAL_CMU_PLL_DDR, HAL_CMU_PLL_USER_PSRAM);
627c814
< static void hal_cmu_osc_to_dig_x4_enable(void)
---
> void hal_cmu_ddr_reset_set()
629,632c816,818
<     aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_X4_ANA_ENABLE;
<     aoncmu->CLK_SELECT |= AON_CMU_SEL_X4_SYS;
<     aoncmu->CLK_SELECT |= AON_CMU_SEL_X4_DIG;
<     aoncmu->RESERVED_03C |= AON_CMU_OSC_TO_DIG_X4;
---
>     cmu->XRESET_SET = SYS_XRST_PSRAM1G | SYS_XRST_PSRAM1GMX | SYS_XRST_GPV_PSRAM1G;
>     cmu->ORESET_SET = SYS_ORST_PSRAM1G;
>     cmu->HRESET_SET = SYS_HRST_PSRAM1G;
635c821
< static void hal_cmu_osc_to_dig_x4_disable(void)
---
> void hal_cmu_ddr_reset_clear()
637,643c823,860
<     aoncmu->CLK_SELECT &= ~AON_CMU_SEL_X4_DIG;
<     aoncmu->RESERVED_03C &= ~AON_CMU_OSC_TO_DIG_X4;
< #ifndef OSC_26M_X4_AUD2BB
<     aoncmu->CLK_SELECT &= ~AON_CMU_SEL_X4_SYS;
< #endif
< #ifndef ANA_26M_X4_ENABLE
<     aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_X4_ANA_DISABLE;
---
>     cmu->XRESET_CLR = SYS_XRST_PSRAM1G | SYS_XRST_PSRAM1GMX | SYS_XRST_GPV_PSRAM1G;
>     cmu->ORESET_CLR = SYS_ORST_PSRAM1G;
>     cmu->HRESET_CLR = SYS_HRST_PSRAM1G;
> }
> 
> int hal_cmu_dsp_set_freq(enum HAL_CMU_FREQ_T freq);
> 
> void hal_cmu_dsi_phy_reset_set(void)
> {
>     hal_cmu_reset_set(HAL_CMU_MOD_Q_DSI_32K);
>     hal_cmu_reset_set(HAL_CMU_MOD_Q_DSI_PN);
>     hal_cmu_reset_set(HAL_CMU_MOD_Q_DSI_TV);
>     hal_cmu_reset_set(HAL_CMU_MOD_Q_DSI_PIX);
>     hal_cmu_reset_set(HAL_CMU_MOD_Q_DSI_DSI);
> }
> 
> void hal_cmu_dsi_phy_reset_clear(void)
> {
>     // TODO: Move clock enable APIs out
>     hal_cmu_clock_enable(HAL_CMU_MOD_Q_DSI_32K);
>     hal_cmu_clock_enable(HAL_CMU_MOD_Q_DSI_PN);
>     hal_cmu_clock_enable(HAL_CMU_MOD_Q_DSI_TV);
>     hal_cmu_clock_enable(HAL_CMU_MOD_Q_DSI_PIX);
>     hal_cmu_clock_enable(HAL_CMU_MOD_Q_DSI_DSI);
> 
>     hal_cmu_reset_clear(HAL_CMU_MOD_Q_DSI_32K);
>     hal_cmu_reset_clear(HAL_CMU_MOD_Q_DSI_PN);
>     hal_cmu_reset_clear(HAL_CMU_MOD_Q_DSI_TV);
>     hal_cmu_reset_clear(HAL_CMU_MOD_Q_DSI_PIX);
>     hal_cmu_reset_clear(HAL_CMU_MOD_Q_DSI_DSI);
> }
> 
> void hal_cmu_dsi_clock_enable(void)
> {
> #if !defined(DSP_ENABLE) && !defined(CHIP_BEST2003_DSP)
>     hal_cmu_dsp_clock_enable();
>     hal_cmu_dsp_reset_clear();
>     hal_sys_timer_delay(US_TO_TICKS(10));
644a862,872
>     hal_cmu_dsp_set_freq(HAL_CMU_FREQ_780M);
>     cmu->DSP_DIV = SET_BITFIELD(cmu->DSP_DIV, CMU_CFG_DIV_APCLK, 0x0);
>     hal_cmu_pll_enable(HAL_CMU_PLL_DSI, HAL_CMU_PLL_USER_DSI);
>     cmu->APCLK_ENABLE = SYS_APCLK_DISPLAY;
>     aoncmu->MIPI_CLK = AON_CMU_EN_CLK_PIX_DSI | AON_CMU_POL_CLK_DSI_IN |
>         SET_BITFIELD(aoncmu->MIPI_CLK, AON_CMU_CFG_DIV_PIX_DSI, 0x4);
>     cmu->QCLK_ENABLE = SYS_QCLK_DSI_DSI | SYS_QCLK_DSI_PIX;
>     hal_sys_timer_delay_us(10);
>     hal_cmu_dsi_reset_set();//QR DSI/PIX CLK bit 4/5; APR APB CLK bit 8
>     hal_sys_timer_delay(US_TO_TICKS(10));
>     hal_cmu_dsi_reset_clear();
647c875,887
< int hal_cmu_sys_set_freq(enum HAL_CMU_FREQ_T freq)
---
> void hal_cmu_dsi_clock_enable_v2(uint8_t pixel_div)
> {
>     hal_cmu_dsp_set_freq(HAL_CMU_FREQ_780M);
>     cmu->DSP_DIV = SET_BITFIELD(cmu->DSP_DIV, CMU_CFG_DIV_APCLK, 0x0);
>     hal_cmu_pll_enable(HAL_CMU_PLL_DSI, HAL_CMU_PLL_USER_DSI);
>     cmu->APCLK_ENABLE = SYS_APCLK_DISPLAY;
>     aoncmu->MIPI_CLK = AON_CMU_EN_CLK_PIX_DSI | AON_CMU_POL_CLK_DSI_IN |
>         SET_BITFIELD(aoncmu->MIPI_CLK, AON_CMU_CFG_DIV_PIX_DSI, pixel_div);
>     cmu->QCLK_ENABLE = SYS_QCLK_DSI_DSI | SYS_QCLK_DSI_PIX;
>     hal_sys_timer_delay_us(10);
> }
> 
> void hal_cmu_dsi_clock_disable(void)
649,653c889,893
<     uint32_t lock;
<     uint32_t enable;
<     uint32_t disable;
<     int div = -1;
<     bool low_sys_set, low_sys_clr;
---
>     aoncmu->MIPI_CLK &= ~(AON_CMU_EN_CLK_PIX_DSI | AON_CMU_POL_CLK_DSI_IN);
>     cmu->QCLK_DISABLE = SYS_QCLK_DSI_DSI | SYS_QCLK_DSI_PIX;
>     cmu->APCLK_DISABLE = SYS_APCLK_DISPLAY;
>     hal_cmu_pll_disable(HAL_CMU_PLL_DSI, HAL_CMU_PLL_USER_DSI);
> }
655,656c895,898
<     if (freq >= HAL_CMU_FREQ_QTY) {
<         return 1;
---
> void hal_cmu_dsi_reset_set(void)
> {
>     cmu->QRESET_SET = SYS_QRST_DSI_DSI | SYS_QRST_DSI_PIX;
>     cmu->APRESET_SET = SYS_APRST_DISPLAY;
659,660c901,906
<     low_sys_set = false;
<     low_sys_clr = false;
---
> void hal_cmu_dsi_reset_clear(void)
> {
>     cmu->APRESET_CLR = SYS_APRST_DISPLAY;
>     cmu->QRESET_CLR = SYS_QRST_DSI_DSI | SYS_QRST_DSI_PIX;
>     hal_sys_timer_delay_us(10);
> }
662c908,911
<     lock = int_lock();
---
> void hal_cmu_dsi_sleep(void)
> {
>     hal_cmu_dsi_clock_disable();
> }
664,666c913,915
<     if (low_sys_freq == HAL_CMU_LOW_SYS_FREQ_NONE) {
<         if (aoncmu->RESERVED_03C & AON_CMU_OSC_TO_DIG_X4) {
<             low_sys_clr = true;
---
> void hal_cmu_dsi_wakeup(void)
> {
>     hal_cmu_dsi_clock_enable();
668,673c917,939
<     } else {
<         if (freq == HAL_CMU_FREQ_26M) {
<             low_sys_set = true;
<         } else if (freq > HAL_CMU_FREQ_26M) {
<             if (aoncmu->RESERVED_03C & AON_CMU_OSC_TO_DIG_X4) {
<                 low_sys_clr = true;
---
> 
> void hal_cmu_lcdc_clock_enable(void)
> {
>     hal_cmu_lcdc_reset_clear();
>     cmu->XCLK_ENABLE = SYS_XCLK_DSI | SYS_XCLK_DISPLAYX | SYS_XCLK_DISPLAYH;
>     cmu->QCLK_ENABLE = SYS_QCLK_DSI_32K | SYS_QCLK_DSI_PN | SYS_QCLK_DSI_TV;
> 
>     hal_cmu_clock_enable(HAL_CMU_MOD_Q_DSI_32K);
>     hal_cmu_clock_enable(HAL_CMU_MOD_Q_DSI_PN);
>     hal_cmu_clock_enable(HAL_CMU_MOD_Q_DSI_TV);
>     hal_cmu_clock_enable(HAL_CMU_MOD_Q_DSI_PIX);
>     hal_cmu_clock_enable(HAL_CMU_MOD_Q_DSI_DSI);
>     hal_cmu_reset_clear(HAL_CMU_MOD_Q_DSI_32K);
>     hal_cmu_reset_clear(HAL_CMU_MOD_Q_DSI_PN);
>     hal_cmu_reset_clear(HAL_CMU_MOD_Q_DSI_TV);
>     hal_cmu_reset_clear(HAL_CMU_MOD_Q_DSI_PIX);
>     hal_cmu_reset_clear(HAL_CMU_MOD_Q_DSI_DSI);
> }
> 
> void hal_cmu_lcdc_clock_disable(void)
> {
>     cmu->QCLK_DISABLE = SYS_QCLK_DSI_32K | SYS_QCLK_DSI_PN | SYS_QCLK_DSI_TV;
>     cmu->XCLK_DISABLE = SYS_XCLK_DSI | SYS_XCLK_DISPLAYX | SYS_XCLK_DISPLAYH;
674a941,952
> 
> void hal_cmu_lcdc_reset_set(void)
> {
>     cmu->QRESET_SET = SYS_QRST_DSI_32K | SYS_QRST_DSI_PN | SYS_QRST_DSI_TV;
>     cmu->XRESET_SET = SYS_XRST_DSI | SYS_XRST_DISPLAYX | SYS_XRST_DISPLAYH;
> }
> 
> void hal_cmu_lcdc_reset_clear(void)
> {
>     cmu->XRESET_CLR = SYS_XRST_DSI | SYS_XRST_DISPLAYX | SYS_XRST_DISPLAYH;
>     cmu->QRESET_CLR = SYS_QRST_DSI_32K | SYS_QRST_DSI_PN | SYS_QRST_DSI_TV;
>     hal_sys_timer_delay_us(10);
675a954,957
> 
> void hal_cmu_lcdc_sleep(void)
> {
>     hal_cmu_lcdc_clock_disable();
678,682c960,962
<     if (low_sys_clr) {
<         low_sys_freq_en = false;
<         cmu->SYS_CLK_ENABLE = CMU_SEL_OSC_SYS_ENABLE;
<         cmu->SYS_CLK_DISABLE = CMU_SEL_OSCX2_SYS_DISABLE | CMU_SEL_PLL_SYS_DISABLE;
<         hal_cmu_osc_to_dig_x4_disable();
---
> void hal_cmu_lcdc_wakeup(void)
> {
>     hal_cmu_lcdc_clock_enable();
684,689c964,975
<     if (low_sys_set) {
<         low_sys_freq_en = true;
<         cmu->SYS_CLK_ENABLE = CMU_SEL_OSC_SYS_ENABLE;
<         cmu->SYS_CLK_DISABLE = CMU_SEL_OSCX2_SYS_DISABLE | CMU_SEL_PLL_SYS_DISABLE;
<         hal_cmu_osc_to_dig_x4_enable();
<         freq = HAL_CMU_FREQ_208M;
---
> void hal_cmu_csi_clock_enable(void)
> {
>     cmu->DSP_DIV = SET_BITFIELD(cmu->DSP_DIV, CMU_CFG_DIV_APCLK, 0x0);
>     aoncmu->MIPI_CLK = AON_CMU_EN_CLK_PIX_CSI | AON_CMU_POL_CLK_CSI_IN |
>         SET_BITFIELD(aoncmu->MIPI_CLK, AON_CMU_CFG_DIV_PIX_CSI, 0x7); //0xa:240M 1lane
>     cmu->APCLK_ENABLE = SYS_APCLK_CSI;
>     cmu->XCLK_ENABLE = SYS_XCLK_CSI;
>     cmu->QCLK_ENABLE = SYS_QCLK_CSI_LANE | SYS_QCLK_CSI_PIX | SYS_QCLK_CSI_LANG;
> 
>     hal_cmu_clock_set_mode(HAL_CMU_MOD_Q_CSI_LANE, HAL_CMU_CLK_AUTO);
>     hal_cmu_clock_set_mode(HAL_CMU_MOD_Q_CSI_PIX, HAL_CMU_CLK_AUTO);
>     hal_cmu_clock_set_mode(HAL_CMU_MOD_Q_CSI_LANG, HAL_CMU_CLK_AUTO);
692c978,1036
<     if (freq == HAL_CMU_FREQ_32K) {
---
> void hal_cmu_csi_clock_disable(void)
> {
>     cmu->XCLK_DISABLE = SYS_XCLK_CSI;
>     cmu->QCLK_ENABLE = SYS_QCLK_CSI_LANE | SYS_QCLK_CSI_PIX | SYS_QCLK_CSI_LANG;
>     cmu->APCLK_DISABLE = SYS_APCLK_CSI;
>     aoncmu->MIPI_CLK &= ~(AON_CMU_EN_CLK_PIX_CSI | AON_CMU_POL_CLK_CSI_IN);
> }
> 
> void hal_cmu_csi_reset_set(void)
> {
>     cmu->XRESET_SET = SYS_XRST_CSI;
>     cmu->QRESET_SET = SYS_QRST_CSI_LANE | SYS_QRST_CSI_PIX | SYS_QRST_CSI_LANG;
>     cmu->APRESET_SET = SYS_APRST_CSI;
> }
> 
> void hal_cmu_csi_reset_clear(void)
> {
>     cmu->APRESET_CLR = SYS_APRST_CSI;
>     cmu->XRESET_CLR = SYS_XRST_CSI;
>     cmu->QRESET_CLR = SYS_QRST_CSI_LANE | SYS_QRST_CSI_PIX | SYS_QRST_CSI_LANG;
>     hal_sys_timer_delay_us(10);
> }
> 
> #ifdef LOW_SYS_FREQ
> #ifdef LOW_SYS_FREQ_6P5M
> int hal_cmu_fast_timer_offline(void)
> {
>     return (cmu_sys_freq == HAL_CMU_FREQ_6P5M);
> }
> #endif
> #endif
> 
> #ifdef CHIP_BEST2003_DSP
> 
> int hal_cmu_sys_set_freq(enum HAL_CMU_FREQ_T freq) __attribute__((alias("hal_cmu_dsp_set_freq")));
> 
> enum HAL_CMU_FREQ_T hal_cmu_sys_get_freq(void) __attribute__((alias("hal_cmu_dsp_get_freq")));
> 
> #else // !CHIP_BEST2003_DSP
> 
> int hal_cmu_sys_set_freq(enum HAL_CMU_FREQ_T freq)
> {
>     uint32_t enable;
>     uint32_t disable;
>     int div;
>     uint32_t lock;
> 
>     if (freq >= HAL_CMU_FREQ_QTY) {
>         return 1;
>     }
> 
> #ifdef LOW_SYS_FREQ
>     cmu_sys_freq = freq;
> #endif
> 
>     div = -1;
> 
>     switch (freq) {
>     case HAL_CMU_FREQ_32K:
694,702c1038,1077
<         disable = CMU_SEL_OSC_SYS_DISABLE | CMU_SEL_OSCX2_SYS_DISABLE |
<             CMU_SEL_PLL_SYS_DISABLE | CMU_RSTN_DIV_SYS_DISABLE | CMU_BYPASS_DIV_SYS_DISABLE;
<     } else if (freq == HAL_CMU_FREQ_26M) {
<         enable = CMU_SEL_OSC_SYS_ENABLE;
<         disable = CMU_SEL_OSCX2_SYS_DISABLE |
<             CMU_SEL_PLL_SYS_DISABLE | CMU_RSTN_DIV_SYS_DISABLE | CMU_BYPASS_DIV_SYS_DISABLE;
<     } else if (freq == HAL_CMU_FREQ_52M) {
<         enable = CMU_SEL_OSCX2_SYS_ENABLE;
<         disable = CMU_SEL_PLL_SYS_DISABLE | CMU_RSTN_DIV_SYS_DISABLE | CMU_BYPASS_DIV_SYS_DISABLE;
---
>         disable = CMU_RSTN_DIV_MCU_DISABLE | CMU_BYPASS_DIV_MCU_DISABLE | CMU_SEL_MCU_OSC_4_DISABLE | CMU_SEL_MCU_OSC_2_DISABLE |
>             CMU_SEL_MCU_OSCX4_DISABLE | CMU_SEL_MCU_SLOW_DISABLE | CMU_SEL_MCU_FAST_DISABLE | CMU_SEL_MCU_PLL_DISABLE;
>         break;
>     case HAL_CMU_FREQ_6P5M:
> #if defined(LOW_SYS_FREQ) && defined(LOW_SYS_FREQ_6P5M)
>         enable = CMU_SEL_MCU_OSC_4_ENABLE;
>         disable = CMU_RSTN_DIV_MCU_DISABLE | CMU_BYPASS_DIV_MCU_DISABLE |
>             CMU_SEL_MCU_OSCX4_DISABLE | CMU_SEL_MCU_SLOW_DISABLE | CMU_SEL_MCU_FAST_DISABLE | CMU_SEL_MCU_PLL_DISABLE;
>         break;
> #endif
>     case HAL_CMU_FREQ_13M:
> #ifdef LOW_SYS_FREQ
>         enable = CMU_SEL_MCU_OSC_2_ENABLE | CMU_SEL_MCU_SLOW_ENABLE;
>         disable = CMU_RSTN_DIV_MCU_DISABLE | CMU_BYPASS_DIV_MCU_DISABLE |
>             CMU_SEL_MCU_OSCX4_DISABLE | CMU_SEL_MCU_FAST_DISABLE | CMU_SEL_MCU_PLL_DISABLE;
>         break;
> #endif
>     case HAL_CMU_FREQ_26M:
>         enable = CMU_SEL_MCU_SLOW_ENABLE;
>         disable = CMU_RSTN_DIV_MCU_DISABLE | CMU_BYPASS_DIV_MCU_DISABLE | CMU_SEL_MCU_OSC_2_ENABLE |
>             CMU_SEL_MCU_OSCX4_DISABLE | CMU_SEL_MCU_FAST_DISABLE | CMU_SEL_MCU_PLL_DISABLE;
>         break;
>     case HAL_CMU_FREQ_52M:
>         enable = CMU_SEL_MCU_FAST_ENABLE;
>         disable = CMU_RSTN_DIV_MCU_DISABLE | CMU_BYPASS_DIV_MCU_DISABLE |
>             CMU_SEL_MCU_OSCX4_DISABLE | CMU_SEL_MCU_PLL_DISABLE;
>         break;
>     case HAL_CMU_FREQ_78M:
>     case HAL_CMU_FREQ_104M:
> #ifdef OSC_26M_X4_AUD2BB
>         enable = CMU_SEL_MCU_OSCX4_ENABLE | CMU_SEL_MCU_FAST_ENABLE;
>         disable = CMU_RSTN_DIV_MCU_DISABLE | CMU_BYPASS_DIV_MCU_DISABLE | CMU_SEL_MCU_PLL_DISABLE;
>         break;
> #endif
>     case HAL_CMU_FREQ_156M:
>     case HAL_CMU_FREQ_208M:
>     case HAL_CMU_FREQ_260M:
>         enable = CMU_RSTN_DIV_MCU_ENABLE | CMU_SEL_MCU_PLL_ENABLE;
>         disable = CMU_BYPASS_DIV_MCU_DISABLE;
>         if (0) {
704,706c1079,1084
<     } else if (freq == HAL_CMU_FREQ_78M) {
<         enable = CMU_SEL_PLL_SYS_ENABLE | CMU_RSTN_DIV_SYS_ENABLE;
<         disable = CMU_BYPASS_DIV_SYS_DISABLE;
---
>         } else if (freq <= HAL_CMU_FREQ_78M) {
>             div = 3;
>         } else if (freq <= HAL_CMU_FREQ_104M) {
>             div = 2;
> #endif
>         } else if (freq <= HAL_CMU_FREQ_156M) {
708,710c1086
<     } else if (freq == HAL_CMU_FREQ_104M) {
<         enable = CMU_SEL_PLL_SYS_ENABLE | CMU_RSTN_DIV_SYS_ENABLE;
<         disable = CMU_BYPASS_DIV_SYS_DISABLE;
---
>         } else { // 208M or 260M
712c1088,1107
< #endif
---
>         }
>         break;
>     case HAL_CMU_FREQ_390M:
>     case HAL_CMU_FREQ_780M:
>     default:
>         enable = CMU_BYPASS_DIV_MCU_ENABLE | CMU_SEL_MCU_PLL_ENABLE;
>         disable = CMU_RSTN_DIV_MCU_DISABLE;
>         break;
>     };
> 
>     if (div >= 0) {
>         lock = int_lock();
>         cmu->SYS_DIV = SET_BITFIELD(cmu->SYS_DIV, CMU_CFG_DIV_MCU, div);
>         int_unlock(lock);
>     }
> 
>     if (enable & CMU_SEL_MCU_PLL_ENABLE) {
>         cmu->SYS_CLK_ENABLE = CMU_RSTN_DIV_MCU_ENABLE;
>         if (enable & CMU_BYPASS_DIV_MCU_ENABLE) {
>             cmu->SYS_CLK_ENABLE = CMU_BYPASS_DIV_MCU_ENABLE;
714,724c1109,1114
<         if (low_sys_set) {
<             if (low_sys_freq == HAL_CMU_LOW_SYS_FREQ_13M) {
<                 enable = CMU_SEL_PLL_SYS_ENABLE | CMU_BYPASS_DIV_SYS_ENABLE;
<                 disable = CMU_RSTN_DIV_SYS_DISABLE;
<             } else {
<                 enable = CMU_SEL_PLL_SYS_ENABLE | CMU_RSTN_DIV_SYS_ENABLE;
<                 disable = CMU_BYPASS_DIV_SYS_DISABLE;
<                 if (low_sys_freq == HAL_CMU_LOW_SYS_FREQ_6P5M) {
<                     div = 0;
<                 } else if (low_sys_freq == HAL_CMU_LOW_SYS_FREQ_4P33M) {
<                     div = 1;
---
>             cmu->SYS_CLK_DISABLE = CMU_BYPASS_DIV_MCU_DISABLE;
>         }
>     }
>     cmu->SYS_CLK_ENABLE = enable;
>     if (enable & CMU_SEL_MCU_PLL_ENABLE) {
>         cmu->SYS_CLK_DISABLE = disable;
726c1116,1118
<                     div = 2;
---
>         cmu->SYS_CLK_DISABLE = disable & ~(CMU_RSTN_DIV_MCU_DISABLE | CMU_BYPASS_DIV_MCU_DISABLE);
>         cmu->SYS_CLK_DISABLE = CMU_BYPASS_DIV_MCU_DISABLE;
>         cmu->SYS_CLK_DISABLE = CMU_RSTN_DIV_MCU_DISABLE;
727a1120,1121
> 
>     return 0;
728a1123,1134
> 
> enum HAL_CMU_FREQ_T BOOT_TEXT_SRAM_LOC hal_cmu_sys_get_freq(void)
> {
>     uint32_t sys_clk;
>     uint32_t div;
> 
>     sys_clk = cmu->SYS_CLK_ENABLE;
> 
>     if (sys_clk & CMU_SEL_MCU_PLL_ENABLE) {
>         if (sys_clk & CMU_BYPASS_DIV_MCU_ENABLE) {
>             // 384M
>             return HAL_CMU_FREQ_390M;
730,731c1136,1148
<             enable = CMU_SEL_PLL_SYS_ENABLE | CMU_BYPASS_DIV_SYS_ENABLE;
<             disable = CMU_RSTN_DIV_SYS_DISABLE;
---
>             div = GET_BITFIELD(cmu->SYS_DIV, CMU_CFG_DIV_MCU);
>             if (div == 0) {
>                 // 192M
>                 return HAL_CMU_FREQ_208M;
>             } else if (div == 1) {
>                 // 128M
>                 return HAL_CMU_FREQ_156M;
>             } else if (div == 2) {
>                 // 96M
>                 return HAL_CMU_FREQ_104M;
>             } else { // div == 3
>                 // 76.8M
>                 return HAL_CMU_FREQ_78M;
734,735c1151,1155
<     if (div >= 0) {
<         cmu->SYS_DIV = SET_BITFIELD(cmu->SYS_DIV, CMU_CFG_DIV_SYS, div);
---
>     } else if (sys_clk & CMU_SEL_MCU_FAST_ENABLE) {
>         if (sys_clk & CMU_SEL_MCU_OSCX4_ENABLE) {
>             return HAL_CMU_FREQ_104M;
>         } else {
>             return HAL_CMU_FREQ_52M;
737,740c1157,1158
<     if (enable & CMU_SEL_PLL_SYS_ENABLE) {
<         cmu->SYS_CLK_ENABLE = CMU_RSTN_DIV_SYS_ENABLE;
<         if (enable & CMU_BYPASS_DIV_SYS_ENABLE) {
<             cmu->SYS_CLK_ENABLE = CMU_BYPASS_DIV_SYS_ENABLE;
---
>     } else if (sys_clk & CMU_SEL_MCU_SLOW_ENABLE) {
>         return HAL_CMU_FREQ_26M;
742c1160
<             cmu->SYS_CLK_DISABLE = CMU_BYPASS_DIV_SYS_DISABLE;
---
>         return HAL_CMU_FREQ_32K;
745,751c1163,1174
<     cmu->SYS_CLK_ENABLE = enable;
<     if (enable & CMU_SEL_PLL_SYS_ENABLE) {
<         cmu->SYS_CLK_DISABLE = disable;
<     } else {
<         cmu->SYS_CLK_DISABLE = disable & ~(CMU_RSTN_DIV_SYS_DISABLE | CMU_BYPASS_DIV_SYS_DISABLE);
<         cmu->SYS_CLK_DISABLE = CMU_BYPASS_DIV_SYS_DISABLE;
<         cmu->SYS_CLK_DISABLE = CMU_RSTN_DIV_SYS_DISABLE;
---
> 
> #endif // !CHIP_BEST2003_DSP
> 
> int hal_cmu_dsp_set_freq(enum HAL_CMU_FREQ_T freq)
> {
>     uint32_t enable;
>     uint32_t disable;
>     int div;
>     uint32_t lock;
> 
>     if (freq >= HAL_CMU_FREQ_QTY) {
>         return 1;
753a1177,1248
> #ifdef CHIP_BEST2003_DSP
> #ifdef LOW_SYS_FREQ
>     cmu_sys_freq = freq;
> #endif
> #endif
> 
>     div = -1;
> 
>     switch (freq) {
>     case HAL_CMU_FREQ_32K:
>         enable = 0;
>         disable = CMU_RSTN_DIV_A7_DISABLE | CMU_BYPASS_DIV_A7_DISABLE | CMU_SEL_A7_OSC_4_DISABLE | CMU_SEL_A7_OSC_2_DISABLE |
>             CMU_SEL_A7_OSCX4_DISABLE | CMU_SEL_A7_SLOW_DISABLE | CMU_SEL_A7_FAST_DISABLE | CMU_SEL_A7_PLL_DISABLE;
>         break;
>     case HAL_CMU_FREQ_6P5M:
> #if defined(LOW_SYS_FREQ) && defined(LOW_SYS_FREQ_6P5M)
>         enable = CMU_SEL_A7_OSC_4_ENABLE;
>         disable = CMU_RSTN_DIV_A7_DISABLE | CMU_BYPASS_DIV_A7_DISABLE |
>             CMU_SEL_A7_OSCX4_DISABLE | CMU_SEL_A7_SLOW_DISABLE | CMU_SEL_A7_FAST_DISABLE | CMU_SEL_A7_PLL_DISABLE;
>         break;
> #endif
>     case HAL_CMU_FREQ_13M:
> #ifdef LOW_SYS_FREQ
>         enable = CMU_SEL_A7_OSC_2_ENABLE | CMU_SEL_A7_SLOW_ENABLE;
>         disable = CMU_RSTN_DIV_A7_DISABLE | CMU_BYPASS_DIV_A7_DISABLE |
>             CMU_SEL_A7_OSCX4_DISABLE | CMU_SEL_A7_FAST_DISABLE | CMU_SEL_A7_PLL_DISABLE;
>         break;
> #endif
>     case HAL_CMU_FREQ_26M:
>         enable = CMU_SEL_A7_SLOW_ENABLE;
>         disable = CMU_RSTN_DIV_A7_DISABLE | CMU_BYPASS_DIV_A7_DISABLE | CMU_SEL_A7_OSC_2_DISABLE |
>             CMU_SEL_A7_OSCX4_DISABLE | CMU_SEL_A7_FAST_DISABLE | CMU_SEL_A7_PLL_DISABLE;
>         break;
>     case HAL_CMU_FREQ_52M:
>         enable = CMU_SEL_A7_FAST_ENABLE;
>         disable = CMU_RSTN_DIV_A7_DISABLE | CMU_BYPASS_DIV_A7_DISABLE |
>             CMU_SEL_A7_OSCX4_DISABLE | CMU_SEL_A7_PLL_DISABLE;
>         break;
>     case HAL_CMU_FREQ_78M:
>     case HAL_CMU_FREQ_104M:
> #ifdef OSC_26M_X4_AUD2BB
>         enable = CMU_SEL_A7_OSCX4_ENABLE | CMU_SEL_A7_FAST_ENABLE;
>         disable = CMU_RSTN_DIV_A7_DISABLE | CMU_BYPASS_DIV_A7_DISABLE | CMU_SEL_A7_PLL_DISABLE;
>         break;
> #endif
>     case HAL_CMU_FREQ_156M:
>     case HAL_CMU_FREQ_208M:
>     case HAL_CMU_FREQ_260M:
>     case HAL_CMU_FREQ_390M:
>         enable = CMU_RSTN_DIV_A7_ENABLE | CMU_SEL_A7_PLL_ENABLE;
>         disable = CMU_BYPASS_DIV_A7_DISABLE;
>         if (0) {
>         } else if (freq <= HAL_CMU_FREQ_156M) {
>             div = 3;
>         } else if (freq <= HAL_CMU_FREQ_208M) {
>             div = 2;
>         } else if (freq <= HAL_CMU_FREQ_260M) {
>             div = 1;
>         } else { // 390M
>             div = 0;
>         }
>         break;
>     case HAL_CMU_FREQ_780M:
>     default:
>         enable = CMU_BYPASS_DIV_A7_ENABLE | CMU_SEL_A7_PLL_ENABLE;
>         disable = CMU_RSTN_DIV_A7_DISABLE;
>         break;
>     };
> 
>     if (div >= 0) {
>         lock = int_lock();
>         cmu->DSP_DIV = SET_BITFIELD(cmu->DSP_DIV, CMU_CFG_DIV_A7, div);
754a1250
>     }
756c1252,1266
<     return 0;
---
>     if (enable & CMU_SEL_A7_PLL_ENABLE) {
>         cmu->SYS_CLK_ENABLE = CMU_RSTN_DIV_A7_ENABLE;
>         if (enable & CMU_BYPASS_DIV_A7_ENABLE) {
>             cmu->SYS_CLK_ENABLE = CMU_BYPASS_DIV_A7_ENABLE;
>         } else {
>             cmu->SYS_CLK_DISABLE = CMU_BYPASS_DIV_A7_DISABLE;
>         }
>     }
>     cmu->SYS_CLK_ENABLE = enable;
>     if (enable & CMU_SEL_A7_PLL_ENABLE) {
>         cmu->SYS_CLK_DISABLE = disable;
>     } else {
>         cmu->SYS_CLK_DISABLE = disable & ~(CMU_RSTN_DIV_A7_DISABLE | CMU_BYPASS_DIV_A7_DISABLE);
>         cmu->SYS_CLK_DISABLE = CMU_BYPASS_DIV_A7_DISABLE;
>         cmu->SYS_CLK_DISABLE = CMU_RSTN_DIV_A7_DISABLE;
758,760d1267
< #else
< SYS_SET_FREQ_FUNC(sys, SYS, {});
< #endif
762,763d1268
< int hal_cmu_mem_set_freq(enum HAL_CMU_FREQ_T freq)
< {
767c1272
< enum HAL_CMU_FREQ_T BOOT_TEXT_SRAM_LOC hal_cmu_sys_get_freq(void)
---
> enum HAL_CMU_FREQ_T BOOT_TEXT_SRAM_LOC hal_cmu_dsp_get_freq(void)
774,776c1279,1281
<     if (sys_clk & CMU_SEL_PLL_SYS_ENABLE) {
<         if (sys_clk & CMU_BYPASS_DIV_SYS_ENABLE) {
<             return HAL_CMU_FREQ_208M;
---
>     if (sys_clk & CMU_SEL_A7_PLL_ENABLE) {
>         if (sys_clk & CMU_BYPASS_DIV_A7_ENABLE) {
>             return HAL_CMU_FREQ_780M;
778c1283
<             div = GET_BITFIELD(cmu->SYS_DIV, CMU_CFG_DIV_SYS);
---
>             div = GET_BITFIELD(cmu->DSP_DIV, CMU_CFG_DIV_A7);
780c1285
<                 return HAL_CMU_FREQ_104M;
---
>                 return HAL_CMU_FREQ_390M;
782,787c1287,1291
<                 // (div == 1): 69M
<                 return HAL_CMU_FREQ_78M;
<             } else {
<                 // (div == 2): 52M
<                 // (div == 3): 42M
<                 return HAL_CMU_FREQ_52M;
---
>                 return HAL_CMU_FREQ_260M;
>             } else if (div == 2) {
>                 return HAL_CMU_FREQ_208M;
>             } else { // div == 3
>                 return HAL_CMU_FREQ_156M;
790c1294,1297
<     } else if (sys_clk & CMU_SEL_OSCX2_SYS_ENABLE) {
---
>     } else if (sys_clk & CMU_SEL_A7_FAST_ENABLE) {
>         if (sys_clk & CMU_SEL_A7_OSCX4_ENABLE) {
>             return HAL_CMU_FREQ_104M;
>         } else {
792c1299,1300
<     } else if (sys_clk & CMU_SEL_OSC_SYS_ENABLE) {
---
>         }
>     } else if (sys_clk & CMU_SEL_A7_SLOW_ENABLE) {
801c1309,1314
<     return hal_cmu_sys_select_pll(pll);
---
>     return 0;
> }
> 
> int BOOT_TEXT_SRAM_LOC hal_cmu_flash1_select_pll(enum HAL_CMU_PLL_T pll)
> {
>     return 0;
806c1319
<     return hal_cmu_sys_select_pll(pll);
---
>     return 0;
809,810c1322
< // hal_cmu_flash_select_pll() requires in BOOT_TEXT_SRAM_LOC
< int BOOT_TEXT_SRAM_LOC hal_cmu_sys_select_pll(enum HAL_CMU_PLL_T pll)
---
> int hal_cmu_dsp_select_pll(enum HAL_CMU_PLL_T pll)
813c1325,1326
<     uint32_t sel;
---
>     uint32_t set;
>     uint32_t clr;
815c1328,1368
<     if (pll >= HAL_CMU_PLL_QTY) {
---
>     if (pll == HAL_CMU_PLL_USB) {
>         set = AON_CMU_SEL_A7_PLLUSB | AON_CMU_SEL_A7_PLLBB;
>         clr = 0;
>     } else if (pll == HAL_CMU_PLL_DSP) {
>         set = 0;
>         clr = AON_CMU_SEL_A7_PLLUSB | AON_CMU_SEL_A7_PLLBB;
>     } else if (pll == HAL_CMU_PLL_BB) {
>         set = AON_CMU_SEL_A7_PLLBB;
>         clr = AON_CMU_SEL_A7_PLLUSB;
>     } else {
>         // == HAL_CMU_PLL_DDR or == HAL_CMU_PLL_BB_PSRAM or >= HAL_CMU_PLL_QTY
>         return 1;
>     }
> 
>     lock = int_lock();
>     aoncmu->DSP_PLL_SELECT = (aoncmu->DSP_PLL_SELECT & ~clr) | set;
>     int_unlock(lock);
> 
>     return 0;
> }
> 
> int BOOT_TEXT_FLASH_LOC hal_cmu_sys_select_pll(enum HAL_CMU_PLL_T pll)
> {
>     uint32_t lock;
>     uint32_t set;
>     uint32_t clr;
> 
>     if (pll == HAL_CMU_PLL_USB) {
>         set = AON_CMU_SEL_MCU_PLLUSB | AON_CMU_SEL_MCU_PLLA7USB;
>         clr = AON_CMU_SEL_MCU_PLLBB_PS;
>     } else if (pll == HAL_CMU_PLL_DSP) {
>         set = AON_CMU_SEL_MCU_PLLA7USB;
>         clr = AON_CMU_SEL_MCU_PLLBB_PS | AON_CMU_SEL_MCU_PLLUSB;
>     } else if (pll == HAL_CMU_PLL_BB) {
>         set = 0;
>         clr = AON_CMU_SEL_MCU_PLLBB_PS | AON_CMU_SEL_MCU_PLLUSB | AON_CMU_SEL_MCU_PLLA7USB;
>     } else if (pll == HAL_CMU_PLL_BB_PSRAM) {
>         set = AON_CMU_SEL_MCU_PLLBB_PS;
>         clr = AON_CMU_SEL_MCU_PLLUSB | AON_CMU_SEL_MCU_PLLA7USB;
>     } else {
>         // == HAL_CMU_PLL_DDR or >= HAL_CMU_PLL_QTY
820,822c1373
<     // 0/1:bbpll, 2:audpll, 3:usbpll
<     sel = (pll == HAL_CMU_PLL_AUD) ? 2 : 0;
<     aoncmu->CLK_SELECT = SET_BITFIELD(aoncmu->CLK_SELECT, AON_CMU_SEL_PLL_SYS, sel);
---
>     aoncmu->FLS_PSR_CLK = (aoncmu->FLS_PSR_CLK & ~clr) | set;
827a1379,1389
> int BOOT_TEXT_FLASH_LOC hal_cmu_audio_select_pll(enum HAL_CMU_PLL_T pll)
> {
>     if (pll == HAL_CMU_PLL_BB) {
>         aoncmu->PCM_I2S_CLK &= ~AON_CMU_SEL_AUD_PLLUSB;
>     } else {
>         aoncmu->PCM_I2S_CLK |= AON_CMU_SEL_AUD_PLLUSB;
>     }
> 
>     return 0;
> }
> 
830c1392,1408
<     return !!(aoncmu->TOP_CLK_ENABLE & ((pll == HAL_CMU_PLL_AUD) ? AON_CMU_EN_CLK_TOP_PLLAUD_ENABLE : AON_CMU_EN_CLK_TOP_PLLUSB_ENABLE));
---
>     bool en;
> 
>     if (pll == HAL_CMU_PLL_USB) {
>         en = !!(aoncmu->TOP_CLK_ENABLE & AON_CMU_EN_CLK_TOP_PLLUSB_ENABLE);
>     } else if (pll == HAL_CMU_PLL_DDR) {
>         en = !!(aoncmu->TOP_CLK_ENABLE & AON_CMU_EN_CLK_TOP_PLLDDR_ENABLE);
>     } else if (pll == HAL_CMU_PLL_DSP) {
>         en = !!(aoncmu->TOP_CLK_ENABLE & AON_CMU_EN_CLK_TOP_PLLA7_ENABLE);
>     } else if (pll == HAL_CMU_PLL_BB) {
>         en = !!(aoncmu->TOP_CLK_ENABLE & AON_CMU_EN_CLK_TOP_PLLBB_ENABLE);
>     } else if (pll == HAL_CMU_PLL_BB_PSRAM) {
>         en = !!(aoncmu->TOP_CLK_ENABLE & AON_CMU_EN_CLK_TOP_PLLBB_PS_ENABLE);
>     } else {
>         en = false;
>     }
> 
>     return en;
833c1411
< int hal_cmu_pll_enable(enum HAL_CMU_PLL_T pll, enum HAL_CMU_PLL_USER_T user)
---
> int BOOT_TEXT_FLASH_LOC hal_cmu_pll_enable(enum HAL_CMU_PLL_T pll, enum HAL_CMU_PLL_USER_T user)
837d1414
<     uint32_t check;
839,841d1415
<     uint32_t sel;
<     uint32_t start;
<     uint32_t timeout;
850,862c1424,1425
< #ifdef USB_USE_USBPLL
<     if (pll == HAL_CMU_PLL_USB && user == HAL_CMU_PLL_USER_USB) {
<         pll = HAL_CMU_PLL_USB_HS;
<     }
< #endif
< 
<     if (pll == HAL_CMU_PLL_AUD) {
<         pu_val = AON_CMU_PU_PLLAUD_ENABLE;
<         en_val = AON_CMU_EN_CLK_TOP_PLLAUD_ENABLE;
<         check = AON_CMU_LOCK_PLLAUD;
< #ifdef USB_USE_USBPLL
<     } else if (pll == HAL_CMU_PLL_USB_HS) {
<         pu_val = AON_CMU_PU_PLLUSB_ENABLE;
---
>     if (pll == HAL_CMU_PLL_USB) {
>         pu_val = AON_CMU_PU_PLLDSI_ENABLE | AON_CMU_PU_PLLDSI_DIV_PS_ENABLE;
864c1427,1437
<         check = AON_CMU_LOCK_PLLUSB;
---
>     } else if (pll == HAL_CMU_PLL_DDR) {
>         pu_val = AON_CMU_PU_PLLDDR_ENABLE;
>         en_val = AON_CMU_EN_CLK_TOP_PLLDDR_ENABLE;
>     } else if (pll == HAL_CMU_PLL_DSP) {
>         pu_val = AON_CMU_PU_PLLA7_ENABLE;
>         en_val = AON_CMU_EN_CLK_TOP_PLLA7_ENABLE;
>     } else if (pll == HAL_CMU_PLL_BB) {
> #ifdef BBPLL_USE_DSI_MCUPLL
>         pu_val = AON_CMU_PU_PLLDSI_ENABLE | AON_CMU_PU_PLLDSI_DIV_MCU_ENABLE;
> #else
>         pu_val = AON_CMU_PU_PLLBB_ENABLE | AON_CMU_PU_PLLBB_DIV_MCU_ENABLE;
866,867d1438
<     } else {
<         pu_val = AON_CMU_PU_PLLBB_ENABLE;
869c1440,1452
<         check = AON_CMU_LOCK_PLLBB;
---
>     } else if (pll == HAL_CMU_PLL_BB_PSRAM) {
> #ifdef BB_PSRAMPLL_USE_DSI_PSRAMPLL
>         pu_val = AON_CMU_PU_PLLDSI_ENABLE | AON_CMU_PU_PLLDSI_DIV_PS_ENABLE;
> #else
>         pu_val = AON_CMU_PU_PLLBB_ENABLE | AON_CMU_PU_PLLBB_DIV_PS_ENABLE;
> #endif
>         en_val = AON_CMU_EN_CLK_TOP_PLLBB_PS_ENABLE;
>     } else if (pll == HAL_CMU_PLL_DSI) {
>         pu_val = AON_CMU_PU_PLLDSI_ENABLE;
>         en_val = 0;
>     } else {
>         pu_val = 0;
>         en_val = 0;
872a1456
> 
877c1461
<         aoncmu->TOP_CLK_ENABLE = pu_val;
---
>         aoncmu->PLL_ENABLE = pu_val;
881a1466
>         hal_sys_timer_delay_us(10);
883,884c1468
<     } else {
<         check = 0;
---
>         aoncmu->TOP_CLK_ENABLE = en_val;
887a1472,1473
>     } else if (user == HAL_CMU_PLL_USER_ALL) {
>         pll_user_map[pll] |= ((1 << user) - 1);
889,894d1474
<     if (user == HAL_CMU_PLL_USER_AUD) {
<         // 0/1:audpll, 2:bbpll, 3:usbpll
<         sel = (pll == HAL_CMU_PLL_AUD) ? 0 : 2;
<         aoncmu->CLK_SELECT = SET_BITFIELD(aoncmu->CLK_SELECT, AON_CMU_SEL_PLL_AUD, sel);
<     }
<     // HAL_CMU_PLL_USER_SYS selects PLL in hal_cmu_sys_select_pll()
897,919c1477
<     start = hal_sys_timer_get();
<     timeout = HAL_CMU_PLL_LOCKED_TIMEOUT;
<     do {
<         if (check) {
<             if (aoncmu->CODEC_DIV & check) {
<                 //break;
<             }
<         } else {
<             if (aoncmu->TOP_CLK_ENABLE & en_val) {
<                 break;
<             }
<         }
<     } while ((hal_sys_timer_get() - start) < timeout);
< 
<     aoncmu->TOP_CLK_ENABLE = en_val;
< 
< #ifndef USB_USE_USBPLL
<     if (pll == HAL_CMU_PLL_USB && user == HAL_CMU_PLL_USER_USB) {
<         aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_TOP_PLLBB2_ENABLE;
<     }
< #endif
< 
<     return (aoncmu->CODEC_DIV & check) ? 0 : 2;
---
>     return 0;
922c1480
< int hal_cmu_pll_disable(enum HAL_CMU_PLL_T pll, enum HAL_CMU_PLL_USER_T user)
---
> int BOOT_TEXT_FLASH_LOC hal_cmu_pll_disable(enum HAL_CMU_PLL_T pll, enum HAL_CMU_PLL_USER_T user)
923a1482,1483
>     uint32_t pu_val;
>     uint32_t en_val;
933,935c1493,1511
<     if (pll == HAL_CMU_PLL_USB && user == HAL_CMU_PLL_USER_USB) {
< #ifdef USB_USE_USBPLL
<         pll = HAL_CMU_PLL_USB_HS;
---
>     if (pll == HAL_CMU_PLL_USB) {
>         pu_val = 0;
>         en_val = AON_CMU_EN_CLK_TOP_PLLUSB_DISABLE;
>     } else if (pll == HAL_CMU_PLL_DDR) {
>         pu_val = AON_CMU_PU_PLLDDR_DISABLE;
>         en_val = AON_CMU_EN_CLK_TOP_PLLDDR_DISABLE;
>     } else if (pll == HAL_CMU_PLL_DSP) {
>         pu_val = AON_CMU_PU_PLLA7_DISABLE;
>         en_val = AON_CMU_EN_CLK_TOP_PLLA7_DISABLE;
>     } else if (pll == HAL_CMU_PLL_BB) {
> #ifdef BBPLL_USE_DSI_MCUPLL
>         pu_val = AON_CMU_PU_PLLDSI_DIV_MCU_DISABLE;
> #else
>         pu_val = AON_CMU_PU_PLLBB_DIV_MCU_DISABLE;
> #endif
>         en_val = AON_CMU_EN_CLK_TOP_PLLBB_DISABLE;
>     } else if (pll == HAL_CMU_PLL_BB_PSRAM) {
> #ifdef BB_PSRAMPLL_USE_DSI_PSRAMPLL
>         pu_val = AON_CMU_PU_PLLDSI_DIV_PS_DISABLE;
937c1513
<         aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_TOP_PLLBB2_DISABLE;
---
>         pu_val = AON_CMU_PU_PLLBB_DIV_PS_DISABLE;
938a1515,1521
>         en_val = AON_CMU_EN_CLK_TOP_PLLBB_PS_DISABLE;
>     } else if (pll == HAL_CMU_PLL_DSI) {
>         pu_val = 0;
>         en_val = 0;
>     } else {
>         pu_val = 0;
>         en_val = 0;
943a1527,1528
>     } else if (user == HAL_CMU_PLL_USER_ALL) {
>         pll_user_map[pll] = 0;
946,956c1531,1557
<         if (pll == HAL_CMU_PLL_AUD) {
<             aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_TOP_PLLAUD_DISABLE;
<             aoncmu->TOP_CLK_DISABLE = AON_CMU_PU_PLLAUD_DISABLE;
< #ifdef USB_USE_USBPLL
<         } else if (pll == HAL_CMU_PLL_USB_HS) {
<             aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_TOP_PLLUSB_DISABLE;
<             aoncmu->TOP_CLK_DISABLE = AON_CMU_PU_PLLUSB_DISABLE;
< #endif
<         } else {
<             aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_TOP_PLLBB_DISABLE;
<             aoncmu->TOP_CLK_DISABLE = AON_CMU_PU_PLLBB_DISABLE;
---
> #if defined(BBPLL_USE_DSI_MCUPLL) && defined(BB_PSRAMPLL_USE_DSI_PSRAMPLL)
>         if (pll_user_map[HAL_CMU_PLL_BB] == 0 && pll_user_map[HAL_CMU_PLL_BB_PSRAM] == 0 &&
>             pll_user_map[HAL_CMU_PLL_USB] == 0 && pll_user_map[HAL_CMU_PLL_DSI] == 0)
>             pu_val |= AON_CMU_PU_PLLBB_DISABLE;
> #elif defined(BBPLL_USE_DSI_MCUPLL) && !defined(BB_PSRAMPLL_USE_DSI_PSRAMPLL)
>         if (pll == HAL_CMU_PLL_BB || pll == HAL_CMU_PLL_USB || pll == HAL_CMU_PLL_DSI) {
>             if (pll_user_map[HAL_CMU_PLL_BB] == 0 && pll_user_map[HAL_CMU_PLL_USB] == 0 &&
>                     pll_user_map[HAL_CMU_PLL_DSI] == 0)
>                 pu_val |= AON_CMU_PU_PLLDSI_DISABLE;
>         } else if (pll == HAL_CMU_PLL_BB_PSRAM) {
>             pu_val |= AON_CMU_PU_PLLBB_DISABLE;
>         }
> #elif !defined(BBPLL_USE_DSI_MCUPLL) && defined(BB_PSRAMPLL_USE_DSI_PSRAMPLL)
>         if (pll == HAL_CMU_PLL_BB_PSRAM || pll == HAL_CMU_PLL_USB || pll == HAL_CMU_PLL_DSI) {
>             if (pll_user_map[HAL_CMU_PLL_BB_PSRAM] == 0 && pll_user_map[HAL_CMU_PLL_USB] == 0 &&
>                     pll_user_map[HAL_CMU_PLL_DSI] == 0)
>                 pu_val |= AON_CMU_PU_PLLDSI_DISABLE;
>         } else if (pll == HAL_CMU_PLL_BB) {
>             pu_val |= AON_CMU_PU_PLLBB_DISABLE;
>         }
> #else
>         if (pll == HAL_CMU_PLL_USB || pll == HAL_CMU_PLL_DSI) {
>             if (pll_user_map[HAL_CMU_PLL_USB] == 0 && pll_user_map[HAL_CMU_PLL_DSI] == 0)
>                 pu_val |= AON_CMU_PU_PLLDSI_DISABLE;
>         } else if (pll == HAL_CMU_PLL_BB || pll == HAL_CMU_PLL_BB_PSRAM) {
>             if (pll_user_map[HAL_CMU_PLL_BB] == 0 && pll_user_map[HAL_CMU_PLL_BB_PSRAM] == 0)
>                 pu_val |= AON_CMU_PU_PLLBB_DISABLE;
957a1559,1561
> #endif
>         aoncmu->TOP_CLK_DISABLE = en_val;
>         aoncmu->PLL_DISABLE = pu_val;
966,978d1569
< #if defined(MCU_HIGH_PERFORMANCE_MODE)
<     hal_cmu_sys_select_pll(HAL_CMU_PLL_USB);
< #else
<     // No need to switch to USB PLL, for there is a clock gate and a clock mux
<     // in front of the AUD/USB switch
<     hal_cmu_sys_select_pll(HAL_CMU_PLL_AUD);
< #endif
< 
< //#ifdef FLASH_LOW_SPEED
< #ifdef OSC_26M_X4_AUD2BB
<     aoncmu->CLK_SELECT &= ~AON_CMU_SEL_X4_SYS;
< #endif
< //#endif
983,984c1574,1575
<     // TODO: Need to lock irq?
<     enum HAL_CMU_PLL_T POSSIBLY_UNUSED pll;
---
>     enum HAL_CMU_PLL_T pll;
>     enum HAL_CMU_FREQ_T switch_freq;
986,990c1577,1578
< #if defined(MCU_HIGH_PERFORMANCE_MODE)
<     pll = HAL_CMU_PLL_USB;
< #else
<     pll = HAL_CMU_PLL_AUD;
< #endif
---
>     // TODO: Select the PLL used by sys
>     pll = HAL_CMU_PLL_BB;
993,1005c1581
<     if (new_freq <= HAL_CMU_FREQ_52M) {
<         aoncmu->CLK_SELECT &= ~AON_CMU_SEL_X4_SYS;
<     }
<     if (new_freq <= HAL_CMU_FREQ_104M && old_freq > HAL_CMU_FREQ_104M) {
<         if (new_freq > HAL_CMU_FREQ_52M) {
<             // PLL is in use now. Switch to X2 first.
<             hal_cmu_sys_set_freq(HAL_CMU_FREQ_52M);
<             aoncmu->CLK_SELECT |= AON_CMU_SEL_X4_SYS;
<             // X4 is in use now
<             hal_cmu_sys_set_freq(new_freq);
<         }
<         hal_cmu_pll_disable(pll, HAL_CMU_PLL_USER_SYS);
<     }
---
>     switch_freq = HAL_CMU_FREQ_104M;
1007,1008c1583,1586
< #ifdef FLASH_LOW_SPEED
<     if (old_freq > HAL_CMU_FREQ_52M && new_freq <= HAL_CMU_FREQ_52M) {
---
>     switch_freq = HAL_CMU_FREQ_52M;
> #endif
> 
>     if (old_freq > switch_freq && new_freq <= switch_freq) {
1011,1012d1588
< #endif
< #endif
1017,1018c1593,1594
<     // TODO: Need to lock irq?
<     enum HAL_CMU_PLL_T POSSIBLY_UNUSED pll;
---
>     enum HAL_CMU_PLL_T pll;
>     enum HAL_CMU_FREQ_T switch_freq;
1020,1021c1596,1600
< #if defined(MCU_HIGH_PERFORMANCE_MODE)
<     pll = HAL_CMU_PLL_USB;
---
>     // TODO: Select the PLL used by sys
>     pll = HAL_CMU_PLL_BB;
> 
> #ifdef OSC_26M_X4_AUD2BB
>     switch_freq = HAL_CMU_FREQ_104M;
1023c1602
<     pll = HAL_CMU_PLL_AUD;
---
>     switch_freq = HAL_CMU_FREQ_52M;
1026,1032c1605
< #ifdef OSC_26M_X4_AUD2BB
<     if (new_freq <= HAL_CMU_FREQ_52M) {
<         aoncmu->CLK_SELECT &= ~AON_CMU_SEL_X4_SYS;
<     } else if (new_freq <= HAL_CMU_FREQ_104M) {
<         aoncmu->CLK_SELECT |= AON_CMU_SEL_X4_SYS;
<     } else {
<         if (old_freq <= HAL_CMU_FREQ_104M) {
---
>     if (old_freq <= switch_freq && new_freq > switch_freq) {
1034,1036d1606
<             if (old_freq > HAL_CMU_FREQ_52M) {
<                 // X4 is in use now. Switch to X2 before stopping X4
<                 hal_cmu_sys_set_freq(HAL_CMU_FREQ_52M);
1038d1607
<             aoncmu->CLK_SELECT &= ~AON_CMU_SEL_X4_SYS;
1039a1609,1617
> 
> void hal_cmu_rom_enable_pll(void)
> {
>     hal_cmu_sys_select_pll(HAL_CMU_PLL_BB);
>     hal_cmu_pll_enable(HAL_CMU_PLL_BB, HAL_CMU_PLL_USER_SYS);
> 
> #if defined(PSRAM_ENABLE) && !defined(PSRAM_LOW_SPEED)
>     hal_cmu_pll_enable(HAL_CMU_PLL_BB_PSRAM, HAL_CMU_PLL_USER_PSRAM);
> #endif
1040a1619,1627
> 
> void BOOT_TEXT_FLASH_LOC hal_cmu_sram_init()
> {
>     uint32_t mcu_ram_size;
> 
> #if defined(ARM_CMSE)
>     mcu_ram_size = RAM5_BASE + RAM5_SIZE - RAM0_BASE;
> #elif defined(ARM_CMNS)
>     mcu_ram_size = RAM_SIZE + RAM_S_SIZE;
1042,1045c1629,1632
< #ifdef FLASH_LOW_SPEED
<     if (old_freq <= HAL_CMU_FREQ_52M && new_freq > HAL_CMU_FREQ_52M) {
<         hal_cmu_pll_enable(pll, HAL_CMU_PLL_USER_SYS);
<     }
---
>     mcu_ram_size = RAM_SIZE;
> #endif
> #if defined(CHIP_HAS_CP) && ((RAMCP_SIZE > 0) || (RAMCPX_SIZE > 0))
>     mcu_ram_size += (RAMCP_SIZE + RAMCPX_SIZE);
1046a1634,1635
> #ifdef __BT_RAMRUN__
>     mcu_ram_size += BT_RAMRUN_SIZE;
1047a1637,1658
> 
>     switch (mcu_ram_size) {
>     case RAM1_BASE - RAM0_BASE: //RAM0
>         cmu->WAKEUP_CLK_CFG = SET_BITFIELD(cmu->WAKEUP_CLK_CFG, CMU_CFG_SRAM_IN_M33, 0x0);
>         break;
>     case RAM2_BASE - RAM0_BASE: //RAM0,1
>         cmu->WAKEUP_CLK_CFG = SET_BITFIELD(cmu->WAKEUP_CLK_CFG, CMU_CFG_SRAM_IN_M33, 0x1);
>         break;
>     case RAM3_BASE - RAM0_BASE: //RAM0,1,2
>         cmu->WAKEUP_CLK_CFG = SET_BITFIELD(cmu->WAKEUP_CLK_CFG, CMU_CFG_SRAM_IN_M33, 0x3);
>         break;
>     case RAM4_BASE - RAM0_BASE: //RAM0,1,2,3
>         cmu->WAKEUP_CLK_CFG = SET_BITFIELD(cmu->WAKEUP_CLK_CFG, CMU_CFG_SRAM_IN_M33, 0x7);
>         break;
>     case RAM5_BASE - RAM0_BASE: //RAM0,1,2,3,4
>         cmu->WAKEUP_CLK_CFG = SET_BITFIELD(cmu->WAKEUP_CLK_CFG, CMU_CFG_SRAM_IN_M33, 0xF);
>         break;
>     case (RAM5_BASE + RAM5_SIZE - RAM0_BASE): //RAM0,1,2,3,4,5
>     default:
>         cmu->WAKEUP_CLK_CFG = SET_BITFIELD(cmu->WAKEUP_CLK_CFG, CMU_CFG_SRAM_IN_M33, 0x1F);
>         break;
>     }
1050c1661
< int hal_cmu_codec_adc_set_div(uint32_t div)
---
> void hal_cmu_programmer_enable_pll(void)
1052c1663,1664
<     uint32_t lock;
---
>     hal_cmu_sram_init();
>     hal_cmu_dma_req_init();
1054,1061c1666,1668
<     if (div < 2) {
<         return 1;
<     }
< 
<     div -= 2;
<     lock = int_lock();
<     aoncmu->CODEC_DIV = SET_BITFIELD(aoncmu->CODEC_DIV, AON_CMU_CFG_DIV_CODEC, div);
<     int_unlock(lock);
---
>     hal_cmu_flash_select_pll(HAL_CMU_PLL_BB);
>     hal_cmu_sys_select_pll(HAL_CMU_PLL_BB);
>     hal_cmu_pll_enable(HAL_CMU_PLL_BB, HAL_CMU_PLL_USER_SYS);
1063c1670,1672
<     return 0;
---
> #if defined(PSRAM_ENABLE) && !defined(PSRAM_LOW_SPEED)
>     hal_cmu_pll_enable(HAL_CMU_PLL_BB_PSRAM, HAL_CMU_PLL_USER_PSRAM);
> #endif
1066c1675
< uint32_t hal_cmu_codec_adc_get_div(void)
---
> void BOOT_TEXT_FLASH_LOC hal_cmu_init_pll_selection(void)
1068,1069c1677
<     return GET_BITFIELD(aoncmu->CODEC_DIV, AON_CMU_CFG_DIV_CODEC) + 2;
< }
---
>     enum HAL_CMU_PLL_T sys;
1071,1074c1679,1682
< int hal_cmu_codec_dac_set_div(uint32_t div)
< {
<     return hal_cmu_codec_adc_set_div(div);
< }
---
> #if !defined(ARM_CMNS)
>     // Disable the PLL which might be enabled in ROM
>     hal_cmu_pll_disable(HAL_CMU_PLL_BB, HAL_CMU_PLL_USER_ALL);
> #endif
1076,1078c1684,1722
< uint32_t hal_cmu_codec_dac_get_div(void)
< {
<     return hal_cmu_codec_adc_get_div();;
---
> #ifdef BBPLL_USE_DSI_MCUPLL
>     aoncmu->FLS_PSR_CLK |= AON_CMU_SEL_MCU_PLLDSI;
> #endif
> 
> #ifdef BB_PSRAMPLL_USE_DSI_PSRAMPLL
>     aoncmu->FLS_PSR_CLK |= AON_CMU_SEL_PSR_PLLDSI;
> #endif
> 
> #ifdef SYS_USE_USBPLL
>     sys = HAL_CMU_PLL_USB;
> #elif defined(SYS_USE_BB_PSRAMPLL)
>     sys = HAL_CMU_PLL_BB_PSRAM;
> #elif defined(SYS_USE_DSPPLL)
>     sys = HAL_CMU_PLL_DSP;
> #else
>     sys = HAL_CMU_PLL_BB;
> #endif
>     hal_cmu_sys_select_pll(sys);
> 
> #ifdef AUDIO_USE_BBPLL
>     hal_cmu_audio_select_pll(HAL_CMU_PLL_BB);
> #else
>     hal_cmu_audio_select_pll(HAL_CMU_PLL_USB);
> #endif
> 
> #ifndef ULTRA_LOW_POWER
>     hal_cmu_pll_enable(sys, HAL_CMU_PLL_USER_SYS);
> #endif
> #if !(defined(FLASH_LOW_SPEED) || defined(OSC_26M_X4_AUD2BB))
>     hal_cmu_pll_enable(HAL_CMU_PLL_BB, HAL_CMU_PLL_USER_FLASH);
> #endif
> #if defined(PSRAM_ENABLE) && !defined(PSRAM_LOW_SPEED)
>     hal_cmu_pll_enable(HAL_CMU_PLL_BB_PSRAM, HAL_CMU_PLL_USER_PSRAM);
> #endif
> 
>     hal_cmu_dsp_timer0_select_slow();
> #ifdef TIMER1_BASE
>     hal_cmu_dsp_timer1_select_fast();
> #endif
1093c1737
<         aoncmu->CLK_SELECT |= AON_CMU_SEL_X4_AUD;
---
>         aoncmu->PCM_I2S_CLK |= AON_CMU_SEL_AUD_X4;
1113c1757
<             aoncmu->CLK_SELECT &= ~AON_CMU_SEL_X4_AUD;
---
>             aoncmu->PCM_I2S_CLK &= ~AON_CMU_SEL_AUD_X4;
1129c1773
<     mask = AON_CMU_SEL_OSC_CODECIIR | AON_CMU_SEL_OSCX2_CODECIIR | AON_CMU_BYPASS_DIV_CODECIIR;
---
>     mask = AON_CMU_SEL_CODECIIR_OSC | AON_CMU_SEL_CODECIIR_OSCX2 | AON_CMU_BYPASS_DIV_CODECIIR;
1133c1777
<         val |= AON_CMU_SEL_OSC_CODECIIR | AON_CMU_SEL_OSCX2_CODECIIR;
---
>         val |= AON_CMU_SEL_CODECIIR_OSC | AON_CMU_SEL_CODECIIR_OSCX2;
1136c1780
<         val |= AON_CMU_SEL_OSCX2_CODECIIR;
---
>         val |= AON_CMU_SEL_CODECIIR_OSCX2;
1156a1801,1802
>             analog_aud_freq_pll_config(CODEC_FREQ_48K_SERIES, CODEC_PLL_DIV);
>             analog_aud_pll_open(ANA_AUD_PLL_USER_IIR);
1157a1804,1805
> 
>        //pmu_iir_freq_config(cfg_speed);
1166c1814
<     aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_CODEC_IIR_ENABLE;
---
>     aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_CODECIIR_ENABLE;
1174a1823
>     bool high_speed;
1176c1825
<     aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_CODEC_IIR_DISABLE;
---
>     aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_CODECIIR_DISABLE;
1182c1831,1833
<     val = AON_CMU_SEL_OSC_CODECIIR | AON_CMU_SEL_OSCX2_CODECIIR;
---
>     high_speed = !(aoncmu->CODEC_IIR & AON_CMU_SEL_CODECIIR_OSC);
> 
>     val = AON_CMU_SEL_CODECIIR_OSC | AON_CMU_SEL_CODECIIR_OSCX2;
1186a1838,1842
> 
>     if (high_speed) {
>         //pmu_iir_freq_config(0);
>     }
>     analog_aud_pll_close(ANA_AUD_PLL_USER_IIR);
1213c1869,1870
<     mask = AON_CMU_SEL_OSC_CODECRS | AON_CMU_SEL_OSCX2_CODECRS | AON_CMU_BYPASS_DIV_CODECRS;
---
>     mask = AON_CMU_SEL_CODECRS0_OSC | AON_CMU_SEL_CODECRS0_OSCX2 | AON_CMU_BYPASS_DIV_CODECRS0;
>     mask |= AON_CMU_SEL_CODECRS1_OSC | AON_CMU_SEL_CODECRS1_OSCX2 | AON_CMU_BYPASS_DIV_CODECRS1;
1217c1874,1875
<         val |= AON_CMU_SEL_OSC_CODECRS | AON_CMU_SEL_OSCX2_CODECRS;
---
>         val |= AON_CMU_SEL_CODECRS0_OSC | AON_CMU_SEL_CODECRS0_OSCX2;
>         val |= AON_CMU_SEL_CODECRS1_OSC | AON_CMU_SEL_CODECRS1_OSCX2;
1220c1878,1879
<         val |= AON_CMU_SEL_OSCX2_CODECRS;
---
>         val |= AON_CMU_SEL_CODECRS0_OSCX2;
>         val |= AON_CMU_SEL_CODECRS1_OSCX2;
1226c1885,1886
<             val |= AON_CMU_BYPASS_DIV_CODECRS;
---
>             val |= AON_CMU_BYPASS_DIV_CODECRS0;
>             val |= AON_CMU_BYPASS_DIV_CODECRS1;
1238c1898,1899
<                 val |= AON_CMU_BYPASS_DIV_CODECRS;
---
>                 val |= AON_CMU_BYPASS_DIV_CODECRS0;
>                 val |= AON_CMU_BYPASS_DIV_CODECRS1;
1240a1902,1903
>             analog_aud_freq_pll_config(CODEC_FREQ_48K_SERIES, CODEC_PLL_DIV);
>             analog_aud_pll_open(ANA_AUD_PLL_USER_RS);
1242,1243d1904
< 
<         pmu_rs_freq_config(cfg_speed);
1252c1913
<     aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_CODEC_RS_ENABLE;
---
>     aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_CODECRS0_ENABLE | AON_CMU_EN_CLK_CODECRS1_ENABLE;
1260c1921
<     bool high_speed;
---
>     //bool high_speed;
1262c1923
<     aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_CODEC_RS_DISABLE;
---
>     aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_CODECRS0_DISABLE | AON_CMU_EN_CLK_CODECRS1_DISABLE;
1268,1269d1928
<     high_speed = !(aoncmu->CODEC_IIR & AON_CMU_SEL_OSC_CODECRS);
< 
1271c1930
<     aoncmu->CODEC_IIR |= AON_CMU_SEL_OSC_CODECRS | AON_CMU_SEL_OSCX2_CODECRS;
---
>     aoncmu->CODEC_IIR |= AON_CMU_SEL_CODECRS0_OSC | AON_CMU_SEL_CODECRS0_OSCX2 | AON_CMU_SEL_CODECRS1_OSC | AON_CMU_SEL_CODECRS1_OSCX2;
1274,1276c1933
<     if (high_speed) {
<         pmu_rs_freq_config(0);
<     }
---
>     analog_aud_pll_close(ANA_AUD_PLL_USER_RS);
1289c1946,1947
<     aoncmu->CODEC_IIR = SET_BITFIELD(aoncmu->CODEC_IIR, AON_CMU_CFG_DIV_CODECRS, div);
---
>     aoncmu->CODEC_IIR = (aoncmu->CODEC_IIR & ~(AON_CMU_CFG_DIV_CODECRS0_MASK | AON_CMU_CFG_DIV_CODECRS1_MASK)) |
>         AON_CMU_CFG_DIV_CODECRS0(div) | AON_CMU_CFG_DIV_CODECRS1(div);
1295,1309d1952
< void hal_cmu_anc_enable(enum HAL_CMU_ANC_CLK_USER_T user)
< {
<     anc_enabled = true;
< }
< 
< void hal_cmu_anc_disable(enum HAL_CMU_ANC_CLK_USER_T user)
< {
<     anc_enabled = false;
< }
< 
< int hal_cmu_anc_get_status(enum HAL_CMU_ANC_CLK_USER_T user)
< {
<     return anc_enabled;
< }
< 
1312,1319d1954
<     uint32_t clk;
< 
< #ifdef CODEC_CLK_FROM_ANA
<     // Always use ANA clock
<     clk = AON_CMU_EN_CLK_CODEC_HCLK_ENABLE | AON_CMU_EN_CLK_CODEC_ENABLE;
< #else
< #ifdef __AUDIO_RESAMPLE__
<     if (hal_cmu_get_audio_resample_status()) {
1320a1956
> 
1322c1958,1959
<         aoncmu->CODEC_DIV |= AON_CMU_SEL_OSC_CODEC;
---
>     aoncmu->CODEC_DIV = (aoncmu->CODEC_DIV & ~(AON_CMU_SEL_CODEC_OSC | AON_CMU_SEL_CODECHCLK_OSCX2 | AON_CMU_SEL_CODEC_ANA_2 | AON_CMU_SEL_CODECHCLK_PLL)) |
>        AON_CMU_SEL_CODEC_OSC_2;
1325,1341c1962
< #ifdef RESAMPLE_CODEC_CLK_ANA
<         clk = AON_CMU_EN_CLK_CODEC_HCLK_ENABLE | AON_CMU_EN_CLK_CODEC_ENABLE;
< #else
<         clk = AON_CMU_EN_CLK_PLL_CODEC_ENABLE | AON_CMU_EN_CLK_CODEC_HCLK_ENABLE | AON_CMU_EN_CLK_CODEC_ENABLE;
<         if (hal_get_chip_metal_id() == HAL_CHIP_METAL_ID_0) {
<             // Force codec to use analog clock
<             clk &= ~AON_CMU_EN_CLK_PLL_CODEC_ENABLE;
<         }
< #endif
<     }
<     else
< #endif
<     {
<         clk = AON_CMU_EN_CLK_PLL_CODEC_ENABLE | AON_CMU_EN_CLK_CODEC_HCLK_ENABLE | AON_CMU_EN_CLK_CODEC_ENABLE;
<     }
< #endif
<     aoncmu->TOP_CLK_ENABLE = clk;
---
>     aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_CODECHCLK_ENABLE | AON_CMU_EN_CLK_CODEC_ENABLE;
1347,1348d1967
<     uint32_t clk;
< 
1349a1969,1970
>     aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_CODECHCLK_DISABLE | AON_CMU_EN_CLK_CODEC_DISABLE;
> }
1351,1355c1972,1973
< #ifdef CODEC_CLK_FROM_ANA
<     clk = AON_CMU_EN_CLK_CODEC_HCLK_DISABLE | AON_CMU_EN_CLK_CODEC_DISABLE;
< #else
< #ifdef __AUDIO_RESAMPLE__
<     if (hal_cmu_get_audio_resample_status()) {
---
> void hal_cmu_codec_vad_clock_enable(int type)
> {
1356a1975
> 
1358c1977
<         aoncmu->CODEC_DIV &= ~AON_CMU_SEL_OSC_CODEC;
---
>     aoncmu->CODEC_DIV |= (AON_CMU_EN_VAD_IIR | AON_CMU_EN_VAD_RS);
1361,1366c1980,1982
<         clk = AON_CMU_EN_CLK_CODEC_HCLK_DISABLE | AON_CMU_EN_CLK_CODEC_DISABLE;
<     }
<     else
< #endif
<     {
<         clk = AON_CMU_EN_CLK_PLL_CODEC_DISABLE | AON_CMU_EN_CLK_CODEC_HCLK_DISABLE | AON_CMU_EN_CLK_CODEC_DISABLE;
---
>     aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_TOP_OSC_ENABLE | AON_CMU_EN_CLK_VAD32K_ENABLE;
>     if (type == AUD_VAD_TYPE_MIX) {
>         aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_CODEC_DISABLE;
1368,1369d1983
< #endif
<     aoncmu->TOP_CLK_DISABLE = clk;
1372c1986
< void hal_cmu_codec_vad_clock_enable(uint32_t enabled)
---
> void hal_cmu_codec_vad_clock_disable(int type)
1374,1377c1988,1992
<     if (enabled) {
<         aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_TOP_OSC_ENABLE | AON_CMU_EN_CLK_32K_CODEC_ENABLE;
<     } else {
<         aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_TOP_OSC_DISABLE | AON_CMU_EN_CLK_32K_CODEC_DISABLE;
---
>     uint32_t lock;
> 
>     aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_TOP_OSC_DISABLE | AON_CMU_EN_CLK_VAD32K_DISABLE;
>     if (type == AUD_VAD_TYPE_MIX) {
>         aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_CODEC_ENABLE;
1378a1994,1997
> 
>     lock = int_lock();
>     aoncmu->CODEC_DIV &= ~(AON_CMU_EN_VAD_IIR | AON_CMU_EN_VAD_RS);
>     int_unlock(lock);
1383c2002
<     aoncmu->RESET_SET = AON_CMU_SOFT_RSTN_CODEC_SET;
---
>     aoncmu->SOFT_RSTN_SET = AON_CMU_SOFT_RSTN_CODEC_SET;
1388c2007,2008
<     aoncmu->RESET_CLR = AON_CMU_SOFT_RSTN_CODEC_CLR;
---
>     hal_cmu_reset_clear(HAL_CMU_MOD_H_CODEC);
>     aoncmu->SOFT_RSTN_CLR = AON_CMU_SOFT_RSTN_CODEC_CLR;
1688a2309,2322
> enum HAL_CMU_USB_CLOCK_SEL_T hal_cmu_usb_rom_select_clock_source(int pll_en, unsigned int crystal)
> {
>     enum HAL_CMU_USB_CLOCK_SEL_T sel;
> 
>     if (crystal == 24000000) {
>         sel = HAL_CMU_USB_CLOCK_SEL_24M_X2;
>     } else {
>         sel = HAL_CMU_USB_CLOCK_SEL_PLL;
>     }
> 
>     hal_cmu_usb_rom_set_clock_source(sel);
> 
>     return sel;
> }
1691d2324
<     usb_clk_sel = sel;
1699d2331
< #if defined(USB_CLK_SRC_26M_X4) || defined(USB_CLK_SRC_26M_X2) || defined(USB_CLK_SRC_24M_X2) || defined(USB_CLK_SRC_48M)
1701,1710d2332
< #error "USB HIGH-SPEED must use PLL"
< #endif
< #if defined(USB_CLK_SRC_26M_X4) && !defined(ANA_26M_X4_ENABLE)
< #error "USB_CLK_SRC_26M_X4 must use ANA_26M_X4_ENABLE"
< #endif
< #endif
< 
< #ifdef ROM_BUILD
< 
< #ifdef USB_USE_USBPLL
1713c2335,2336
<     if (usb_clk_sel == HAL_CMU_USB_CLOCK_SEL_24M_X2) {
---
> #ifndef USB_USE_USBPLL
>     if (hal_cmu_get_crystal_freq() == 24000000)
1715,1723c2338
<     } else if (usb_clk_sel == HAL_CMU_USB_CLOCK_SEL_48M) {
<         src = CMU_USB_CLK_SRC_OSC_48M;
<     } else if (usb_clk_sel == HAL_CMU_USB_CLOCK_SEL_26M_X2) {
<         src = CMU_USB_CLK_SRC_OSC_26M_X2;
<     } else if (usb_clk_sel == HAL_CMU_USB_CLOCK_SEL_26M_X4) {
<         src = CMU_USB_CLK_SRC_OSC_26M_X4;
<     } else {
<         src = CMU_USB_CLK_SRC_PLL_48M;
<     }
---
>     else
1725,1739d2339
< 
< #else // !ROM_BUILD
< 
< #ifdef USB_USE_USBPLL
<     src = CMU_USB_CLK_SRC_PLL_60M;
< #else
< #ifdef USB_CLK_SRC_24M_X2
<     src = CMU_USB_CLK_SRC_OSC_24M_X2;
< #elif defined(USB_CLK_SRC_48M)
<     src = CMU_USB_CLK_SRC_OSC_48M;
< #elif defined(USB_CLK_SRC_26M_X4)
<     src = CMU_USB_CLK_SRC_OSC_26M_X4;
< #elif defined(USB_CLK_SRC_26M_X2)
<     src = CMU_USB_CLK_SRC_OSC_26M_X2;
< #else
1742,1744d2341
< #endif
< 
< #endif // !ROM_BUILD
1753a2351
>     POSSIBLY_UNUSED uint32_t div;
1754a2353
> #if !defined(USB_HIGH_SPEED) && defined(USB_USE_USBPLL)
1755a2355,2357
> #else
>     pll = HAL_CMU_PLL_BB;
> #endif
1757,1759c2359
< 
<     if (src == CMU_USB_CLK_SRC_PLL_60M || src == CMU_USB_CLK_SRC_PLL_60M_ALT ||
<             src == CMU_USB_CLK_SRC_PLL_48M) {
---
>     if (src != CMU_USB_CLK_SRC_OSC_24M_X2)
1761d2360
<     }
1764,1765c2363,2377
< #ifdef USB_CLK_SRC_26M_X4
<     aoncmu->CLK_SELECT |= AON_CMU_SEL_X4_USB;
---
> #ifdef USB_HIGH_SPEED
>     cmu->SYS_DIV = SET_BITFIELD(cmu->SYS_DIV, CMU_SEL_USB_SRC, 1);
> #else
>     cmu->SYS_DIV = SET_BITFIELD(cmu->SYS_DIV, CMU_SEL_USB_SRC, 0);
>     if (src == CMU_USB_CLK_SRC_OSC_24M_X2) {
>         aoncmu->CLK_SELECT |= AON_CMU_SEL_USB_OSCX2;
>     } else {
> #ifdef USB_USE_USBPLL
>         aoncmu->CLK_SELECT |= AON_CMU_SEL_USB_PLLUSB;
>         // DSI PSRAMPLL to dig: ?
>         div = 8;///TODO:
> #else // USB usb BBPLL
>         aoncmu->CLK_SELECT &= ~AON_CMU_SEL_USB_PLLUSB;
>         // BBPLL to dig: 384M
>         div = 8;
1767c2379,2382
<     cmu->SYS_DIV = SET_BITFIELD(cmu->SYS_DIV, CMU_SEL_USB_SRC, src);
---
>         aoncmu->CLK_SELECT = SET_BITFIELD(aoncmu->CLK_SELECT, AON_CMU_CFG_DIV_USB, div-2);
>         aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_USB_PLL_ENABLE;
>     }
> #endif /*USB_HIGH_SPEED*/
1793d2407
<     uint32_t src;
1794a2409
> #if !defined(USB_HIGH_SPEED) && defined(USB_USE_USBPLL)
1796c2411,2413
<     src = hal_cmu_usb_get_clock_source();
---
> #else
>     pll = HAL_CMU_PLL_BB;
> #endif
1809a2427,2429
> #ifndef USB_HIGH_SPEED
>     aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_USB_PLL_DISABLE;
> #endif
1811,1812c2431
<     if (src == CMU_USB_CLK_SRC_PLL_60M || src == CMU_USB_CLK_SRC_PLL_60M_ALT ||
<             src == CMU_USB_CLK_SRC_PLL_48M) {
---
>     if (hal_cmu_usb_get_clock_source() != CMU_USB_CLK_SRC_OSC_24M_X2)
1815d2433
< }
1820c2438
<     // Divider defaults to 2 (reg_val = div - 2)
---
>     // Divider defaults to 2 (div = reg_val + 2)
1830,1831d2447
<         aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_PLL_PER_DISABLE;
<         if (div > ((AON_CMU_CFG_DIV_PER_MASK >> AON_CMU_CFG_DIV_PER_SHIFT) + 2)) {
1833d2448
<         }
1844d2458
<         aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_PLL_PER_ENABLE;
1872,1873c2486,2488
< PERPH_SET_DIV_FUNC(spi, SPI1, SYS_DIV);
< PERPH_SET_DIV_FUNC(slcd, SPI0, SYS_DIV);
---
> PERPH_SET_DIV_FUNC(uart3, UART3, UART_CLK);
> PERPH_SET_DIV_FUNC(spi, SPI0, SYS_DIV);
> PERPH_SET_DIV_FUNC(slcd, SPI1, SYS_DIV);
1897,1898c2512,2514
< PERPH_SET_FREQ_FUNC(spi, SPI1, SYS_DIV);
< PERPH_SET_FREQ_FUNC(slcd, SPI0, SYS_DIV);
---
> PERPH_SET_FREQ_FUNC(uart3, UART3, UART_CLK);
> PERPH_SET_FREQ_FUNC(spi, SPI0, SYS_DIV);
> PERPH_SET_FREQ_FUNC(slcd, SPI1, SYS_DIV);
1919a2536,2551
> void hal_cmu_sec_eng_clock_enable(void)
> {
>     hal_cmu_clock_enable(HAL_CMU_MOD_H_SEC_ENG);
>     hal_cmu_clock_enable(HAL_CMU_MOD_P_SEC_ENG);
>     hal_cmu_reset_clear(HAL_CMU_MOD_H_SEC_ENG);
>     hal_cmu_reset_clear(HAL_CMU_MOD_P_SEC_ENG);
> }
> 
> void hal_cmu_sec_eng_clock_disable(void)
> {
>     hal_cmu_reset_set(HAL_CMU_MOD_H_SEC_ENG);
>     hal_cmu_reset_set(HAL_CMU_MOD_P_SEC_ENG);
>     hal_cmu_clock_disable(HAL_CMU_MOD_H_SEC_ENG);
>     hal_cmu_clock_disable(HAL_CMU_MOD_P_SEC_ENG);
> }
> 
1930a2563
>         CMU_CLK_OUT_SEL_WF      = 4,
1941c2574
<     } else if (HAL_CMU_CLOCK_OUT_MCU_32K <= id && id <= HAL_CMU_CLOCK_OUT_MCU_SPI1) {
---
>     } else if (HAL_CMU_CLOCK_OUT_MCU_32K <= id && id <= HAL_CMU_CLOCK_OUT_MCU_I2S1) {
1949c2582
<     } else if (HAL_CMU_CLOCK_OUT_BT_32K <= id && id <= HAL_CMU_CLOCK_OUT_BT_26M) {
---
>     } else if (HAL_CMU_CLOCK_OUT_BT_NONE <= id && id <= HAL_CMU_CLOCK_OUT_BT_DACD8) {
1951c2584,2587
<         btcmu->CLK_OUT = SET_BITFIELD(btcmu->CLK_OUT, BT_CMU_CFG_CLK_OUT, id - HAL_CMU_CLOCK_OUT_BT_32K);
---
>         btcmu->CLK_OUT = SET_BITFIELD(btcmu->CLK_OUT, BT_CMU_CFG_CLK_OUT, id - HAL_CMU_CLOCK_OUT_BT_NONE);
>     } else if (HAL_CMU_CLOCK_OUT_WF_32K <= id && id <= HAL_CMU_CLOCK_OUT_WF_BBDIGFIFO) {
>         sel = CMU_CLK_OUT_SEL_WF;
>         wlancmu->CLK_OUT = SET_BITFIELD(wlancmu->CLK_OUT, WLAN_CMU_CFG_CLK_OUT, id - HAL_CMU_CLOCK_OUT_WF_32K);
1980c2616
<     aoncmu->PCM_I2S_CLK = SET_BITFIELD(aoncmu->PCM_I2S_CLK, AON_CMU_SEL_I2S_MCLK, id) | AON_CMU_EN_I2S_MCLK;
---
>     aoncmu->CODEC_DIV = SET_BITFIELD(aoncmu->CODEC_DIV, AON_CMU_SEL_I2S_MCLK, id) | AON_CMU_EN_I2S_MCLK;
1991c2627
<     aoncmu->PCM_I2S_CLK &= ~AON_CMU_EN_I2S_MCLK;
---
>     aoncmu->CODEC_DIV &= ~AON_CMU_EN_I2S_MCLK;
2012c2648
<             return 1;
---
>             return -1;
2017c2653
<             return 1;
---
>             return -2;
2023,2024c2659,2660
<         aoncmu->PWM01_CLK = (aoncmu->PWM01_CLK & ~(AON_CMU_CFG_DIV_PWM0_MASK | AON_CMU_SEL_OSC_PWM0 | AON_CMU_EN_OSC_PWM0)) |
<             AON_CMU_CFG_DIV_PWM0(div) | (clk_32k ? 0 : (AON_CMU_SEL_OSC_PWM0 | AON_CMU_EN_OSC_PWM0));
---
>         aoncmu->PWM01_CLK = (aoncmu->PWM01_CLK & ~(AON_CMU_CFG_DIV_PWM0_MASK | AON_CMU_SEL_PWM0_OSC | AON_CMU_EN_CLK_PWM0_OSC)) |
>             AON_CMU_CFG_DIV_PWM0(div) | (clk_32k ? 0 : (AON_CMU_SEL_PWM0_OSC | AON_CMU_EN_CLK_PWM0_OSC));
2026,2027c2662,2663
<         aoncmu->PWM01_CLK = (aoncmu->PWM01_CLK & ~(AON_CMU_CFG_DIV_PWM1_MASK | AON_CMU_SEL_OSC_PWM1 | AON_CMU_EN_OSC_PWM1)) |
<             AON_CMU_CFG_DIV_PWM1(div) | (clk_32k ? 0 : (AON_CMU_SEL_OSC_PWM1 | AON_CMU_EN_OSC_PWM1));
---
>         aoncmu->PWM01_CLK = (aoncmu->PWM01_CLK & ~(AON_CMU_CFG_DIV_PWM1_MASK | AON_CMU_SEL_PWM1_OSC | AON_CMU_EN_CLK_PWM1_OSC)) |
>             AON_CMU_CFG_DIV_PWM1(div) | (clk_32k ? 0 : (AON_CMU_SEL_PWM1_OSC | AON_CMU_EN_CLK_PWM1_OSC));
2029,2030c2665,2681
<         aoncmu->PWM23_CLK = (aoncmu->PWM23_CLK & ~(AON_CMU_CFG_DIV_PWM2_MASK | AON_CMU_SEL_OSC_PWM2 | AON_CMU_EN_OSC_PWM2)) |
<             AON_CMU_CFG_DIV_PWM2(div) | (clk_32k ? 0 : (AON_CMU_SEL_OSC_PWM2 | AON_CMU_EN_OSC_PWM2));
---
>         aoncmu->PWM23_CLK = (aoncmu->PWM23_CLK & ~(AON_CMU_CFG_DIV_PWM2_MASK | AON_CMU_SEL_PWM2_OSC | AON_CMU_EN_CLK_PWM2_OSC)) |
>             AON_CMU_CFG_DIV_PWM2(div) | (clk_32k ? 0 : (AON_CMU_SEL_PWM2_OSC | AON_CMU_EN_CLK_PWM2_OSC));
>     } else if (id == HAL_PWM_ID_3) {
>         aoncmu->PWM23_CLK = (aoncmu->PWM23_CLK & ~(AON_CMU_CFG_DIV_PWM3_MASK | AON_CMU_SEL_PWM3_OSC | AON_CMU_EN_CLK_PWM3_OSC)) |
>             AON_CMU_CFG_DIV_PWM3(div) | (clk_32k ? 0 : (AON_CMU_SEL_PWM3_OSC | AON_CMU_EN_CLK_PWM3_OSC));
>     } else if (id == HAL_PWM1_ID_0) {
>         aoncmu->PWM45_CLK = (aoncmu->PWM45_CLK & ~(AON_CMU_CFG_DIV_PWM4_MASK | AON_CMU_SEL_PWM4_OSC | AON_CMU_EN_CLK_PWM4_OSC)) |
>             AON_CMU_CFG_DIV_PWM4(div) | (clk_32k ? 0 : (AON_CMU_SEL_PWM4_OSC | AON_CMU_EN_CLK_PWM4_OSC));
>     } else if (id == HAL_PWM1_ID_1) {
>         aoncmu->PWM45_CLK = (aoncmu->PWM45_CLK & ~(AON_CMU_CFG_DIV_PWM5_MASK | AON_CMU_SEL_PWM5_OSC | AON_CMU_EN_CLK_PWM5_OSC)) |
>             AON_CMU_CFG_DIV_PWM5(div) | (clk_32k ? 0 : (AON_CMU_SEL_PWM5_OSC | AON_CMU_EN_CLK_PWM5_OSC));
>     } else if (id == HAL_PWM1_ID_2) {
>         aoncmu->PWM67_CLK = (aoncmu->PWM67_CLK & ~(AON_CMU_CFG_DIV_PWM6_MASK | AON_CMU_SEL_PWM6_OSC | AON_CMU_EN_CLK_PWM6_OSC)) |
>             AON_CMU_CFG_DIV_PWM6(div) | (clk_32k ? 0 : (AON_CMU_SEL_PWM6_OSC | AON_CMU_EN_CLK_PWM6_OSC));
>     } else if (id == HAL_PWM1_ID_3) {
>         aoncmu->PWM67_CLK = (aoncmu->PWM67_CLK & ~(AON_CMU_CFG_DIV_PWM7_MASK | AON_CMU_SEL_PWM7_OSC | AON_CMU_EN_CLK_PWM7_OSC)) |
>             AON_CMU_CFG_DIV_PWM7(div) | (clk_32k ? 0 : (AON_CMU_SEL_PWM7_OSC | AON_CMU_EN_CLK_PWM7_OSC));
2032,2033c2683
<         aoncmu->PWM23_CLK = (aoncmu->PWM23_CLK & ~(AON_CMU_CFG_DIV_PWM3_MASK | AON_CMU_SEL_OSC_PWM3 | AON_CMU_EN_OSC_PWM3)) |
<             AON_CMU_CFG_DIV_PWM3(div) | (clk_32k ? 0 : (AON_CMU_SEL_OSC_PWM3 | AON_CMU_EN_OSC_PWM3));
---
>         ASSERT(0,"PWM id error!");
2066a2717,2726
> void hal_cmu_jtag_set_cp(void)
> {
>     cmu->PERIPH_CLK |= CMU_JTAG_SEL_CP;
> }
> 
> void hal_cmu_jtag_set_a7(void)
> {
>     cmu->PERIPH_CLK |= CMU_JTAG_SEL_A7;
> }
> 
2069,2070c2729
<     aoncmu->CODEC_DIV = (aoncmu->CODEC_DIV & ~AON_CMU_SEL_CLK_OSCX2) |
<         AON_CMU_BYPASS_LOCK_PLLBB | AON_CMU_BYPASS_LOCK_PLLAUD | AON_CMU_SEL_CLK_OSC;
---
>     aoncmu->CODEC_DIV = (aoncmu->CODEC_DIV & ~AON_CMU_SEL_AON_OSCX2) | AON_CMU_SEL_AON_OSC;
2072,2074c2731,2736
<     aoncmu->CLK_OUT &= ~(AON_CMU_SEL_DCDC_PLL | AON_CMU_SEL_DCDC_OSCX2);
<     aoncmu->CLK_OUT |= AON_CMU_BYPASS_DIV_DCDC;
<     aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_DCDC0_ENABLE;
---
>     //aoncmu->CLK_OUT = (aoncmu->CLK_OUT & ~AON_CMU_SEL_DCDC_PLL) | AON_CMU_SEL_DCDC_OSC | AON_CMU_BYPASS_DIV_DCDC | AON_CMU_EN_CLK_DCDC0;
> 
>     hal_cmu_dma_req_init();
> 
>     // Debug Select CMU REG F4
>     cmu->MCU_TIMER = SET_BITFIELD(cmu->MCU_TIMER, CMU_DEBUG_REG_SEL, CMU_DEBUG_REG_SEL_DEBUG);
2086,2087c2748,2753
<     // Enable OSCX2 for MCU peripheral
<     aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_OSCX2_MCU_ENABLE;
---
>     // Power on OSCX2
>     aoncmu->PLL_ENABLE = AON_CMU_PU_OSCX2_ENABLE;
>     // Disable DIG OSCX2
>     aoncmu->CLK_SELECT &= ~AON_CMU_SEL_OSCX2_DIG;
>     // Enable OSCX2
>     aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_TOP_OSCX2_ENABLE | AON_CMU_EN_CLK_MCU_OSCX2_ENABLE;
2093,2097c2759,2764
<     aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_X4_ANA_ENABLE;
< #endif
< #ifdef OSC_26M_X4_AUD2BB
<     aoncmu->CLK_SELECT |= AON_CMU_SEL_X4_SYS;
<     aoncmu->CLK_SELECT &= ~AON_CMU_SEL_X4_DIG;
---
>     // Power on OSCX4
>     aoncmu->PLL_ENABLE = AON_CMU_PU_OSCX4_ENABLE;
>     // Disable DIG OSCX4
>     aoncmu->CLK_SELECT &= ~AON_CMU_SEL_OSCX4_DIG;
>     // Enable OSCX4
>     aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_TOP_OSCX4_ENABLE;
2101c2768,2814
< void BOOT_TEXT_FLASH_LOC hal_cmu_module_init_state(void)
---
> struct CMU_DMA_PER_2_REQ_T {
>     enum HAL_DMA_PERIPH_T periph;
>     enum CMU_DMA_REQ_T req;
> };
> const static BOOT_RODATA_FLASH_LOC struct CMU_DMA_PER_2_REQ_T periph_map[] = {
>     {HAL_DMA_PERIPH_NULL,   CMU_DMA_REQ_NULL},
>     {HAL_AUDMA_CODEC_RX,    CMU_DMA_REQ_CODEC_RX},
>     {HAL_AUDMA_CODEC_TX,    CMU_DMA_REQ_CODEC_TX},
>     {HAL_AUDMA_DSD_RX,      CMU_DMA_REQ_DSD_RX},
>     {HAL_AUDMA_DSD_TX,      CMU_DMA_REQ_DSD_TX},
>     {HAL_GPDMA_IR_RX,       CMU_DMA_REQ_IR_RX},
>     {HAL_GPDMA_IR_TX,       CMU_DMA_REQ_IR_TX},
>     {HAL_GPDMA_FLASH1,      CMU_DMA_REQ_FLS1},
>     {HAL_GPDMA_FLASH0,      CMU_DMA_REQ_FLS0},
>     {HAL_AUDMA_BTDUMP,      CMU_DMA_REQ_BTDUMP},
>     {HAL_GPDMA_SDMMC,       CMU_DMA_REQ_SDEMMC},
>     {HAL_GPDMA_I2C0_RX,     CMU_DMA_REQ_I2C0_RX},
>     {HAL_GPDMA_I2C0_TX,     CMU_DMA_REQ_I2C0_TX},
>     {HAL_GPDMA_I2C1_RX,     CMU_DMA_REQ_I2C1_RX},
>     {HAL_GPDMA_I2C1_TX,     CMU_DMA_REQ_I2C1_TX},
>     {HAL_GPDMA_I2C2_RX,     CMU_DMA_REQ_I2C2_RX},
>     {HAL_GPDMA_I2C2_TX,     CMU_DMA_REQ_I2C2_TX},
>     {HAL_GPDMA_SPI_RX,      CMU_DMA_REQ_SPILCD0_RX},
>     {HAL_GPDMA_SPI_TX,      CMU_DMA_REQ_SPILCD0_TX},
>     {HAL_GPDMA_SPILCD_RX,   CMU_DMA_REQ_SPILCD1_RX},
>     {HAL_GPDMA_SPILCD_TX,   CMU_DMA_REQ_SPILCD1_TX},
>     {HAL_GPDMA_ISPI_RX,     CMU_DMA_REQ_SPI_ITN_RX},
>     {HAL_GPDMA_ISPI_TX,     CMU_DMA_REQ_SPI_ITN_TX},
>     {HAL_GPDMA_UART0_RX,    CMU_DMA_REQ_UART0_RX},
>     {HAL_GPDMA_UART0_TX,    CMU_DMA_REQ_UART0_TX},
>     {HAL_GPDMA_UART1_RX,    CMU_DMA_REQ_UART1_RX},
>     {HAL_GPDMA_UART1_TX,    CMU_DMA_REQ_UART1_TX},
>     {HAL_GPDMA_UART2_RX,    CMU_DMA_REQ_UART2_RX},
>     {HAL_GPDMA_UART2_TX,    CMU_DMA_REQ_UART2_TX},
>     {HAL_GPDMA_UART3_RX,    CMU_DMA_REQ_UART3_RX},
>     {HAL_GPDMA_UART3_TX,    CMU_DMA_REQ_UART3_TX},
>     {HAL_AUDMA_BTPCM_RX,    CMU_DMA_REQ_PCM_RX},
>     {HAL_AUDMA_BTPCM_TX,    CMU_DMA_REQ_PCM_TX},
>     {HAL_AUDMA_I2S0_RX,     CMU_DMA_REQ_I2S0_RX},
>     {HAL_AUDMA_I2S0_TX,     CMU_DMA_REQ_I2S0_TX},
>     {HAL_AUDMA_I2S1_RX,     CMU_DMA_REQ_I2S1_RX},
>     {HAL_AUDMA_I2S1_TX,     CMU_DMA_REQ_I2S1_TX},
>     {HAL_AUDMA_SPDIF0_RX,   CMU_DMA_REQ_SPDIF0_RX},
>     {HAL_AUDMA_SPDIF0_TX,   CMU_DMA_REQ_SPDIF0_TX},
> };
> 
> enum CMU_DMA_REQ_T BOOT_TEXT_FLASH_LOC hal_dma_periph_2_idx(enum HAL_DMA_PERIPH_T periph)
2103,2106c2816,2821
<     aoncmu->CODEC_DIV = (aoncmu->CODEC_DIV & ~AON_CMU_SEL_CLK_OSCX2) |
<         AON_CMU_BYPASS_LOCK_PLLBB | AON_CMU_BYPASS_LOCK_PLLAUD | AON_CMU_SEL_CLK_OSC;
<     // Slow down PMU fast clock
<     aoncmu->CLK_OUT = (aoncmu->CLK_OUT & ~(AON_CMU_BYPASS_DIV_DCDC | AON_CMU_CFG_DIV_DCDC_MASK)) | AON_CMU_CFG_DIV_DCDC(2);
---
>     uint32_t i;
>     for (i=0; i<ARRAY_SIZE(periph_map); ++i)
>         if (periph_map[i].periph == periph)
>             return periph_map[i].req;
>     return CMU_DMA_REQ_NULL;
> }
2107a2823,2824
> void BOOT_TEXT_FLASH_LOC hal_cmu_dma_req_init(void)
> {
2110,2120c2827,2831
<         // codec
<         CMU_ADMA_CH0_REQ_IDX(0) | CMU_ADMA_CH1_REQ_IDX(1) |
< #ifdef CODEC_DSD
<         // codec_dsd
<         CMU_ADMA_CH2_REQ_IDX(16) | CMU_ADMA_CH3_REQ_IDX(17) |
< #else
<         // btpcm
<         CMU_ADMA_CH2_REQ_IDX(2) | CMU_ADMA_CH3_REQ_IDX(3) |
< #endif
<         // i2s0
<         CMU_ADMA_CH4_REQ_IDX(4);
---
>         CMU_ADMA_CH0_REQ_IDX(hal_dma_periph_2_idx(bes2003_audma_fifo_periph[0])) |
>         CMU_ADMA_CH1_REQ_IDX(hal_dma_periph_2_idx(bes2003_audma_fifo_periph[1])) |
>         CMU_ADMA_CH2_REQ_IDX(hal_dma_periph_2_idx(bes2003_audma_fifo_periph[2])) |
>         CMU_ADMA_CH3_REQ_IDX(hal_dma_periph_2_idx(bes2003_audma_fifo_periph[3])) |
>         CMU_ADMA_CH4_REQ_IDX(hal_dma_periph_2_idx(bes2003_audma_fifo_periph[4]));
2122,2127c2833,2837
<         // i2s0
<         CMU_ADMA_CH5_REQ_IDX(5) |
<         // fir
<         CMU_ADMA_CH6_REQ_IDX(6) | CMU_ADMA_CH7_REQ_IDX(7) |
<         // spdif
<         CMU_ADMA_CH8_REQ_IDX(8) | CMU_ADMA_CH9_REQ_IDX(9);
---
>         CMU_ADMA_CH5_REQ_IDX(hal_dma_periph_2_idx(bes2003_audma_fifo_periph[5])) |
>         CMU_ADMA_CH6_REQ_IDX(hal_dma_periph_2_idx(bes2003_audma_fifo_periph[6])) |
>         CMU_ADMA_CH7_REQ_IDX(hal_dma_periph_2_idx(bes2003_audma_fifo_periph[7])) |
>         CMU_ADMA_CH8_REQ_IDX(hal_dma_periph_2_idx(bes2003_audma_fifo_periph[8])) |
>         CMU_ADMA_CH9_REQ_IDX(hal_dma_periph_2_idx(bes2003_audma_fifo_periph[9]));
2129,2136c2839,2843
<         // iir
<         CMU_ADMA_CH10_REQ_IDX(10) | CMU_ADMA_CH11_REQ_IDX(11) |
<         // btdump
<         CMU_ADMA_CH12_REQ_IDX(12) |
<         // mc
<         CMU_ADMA_CH13_REQ_IDX(13) |
<         // i2s1
<         CMU_ADMA_CH14_REQ_IDX(18);
---
>         CMU_ADMA_CH10_REQ_IDX(hal_dma_periph_2_idx(bes2003_audma_fifo_periph[10])) |
>         CMU_ADMA_CH11_REQ_IDX(hal_dma_periph_2_idx(bes2003_audma_fifo_periph[11])) |
>         CMU_ADMA_CH12_REQ_IDX(hal_dma_periph_2_idx(bes2003_audma_fifo_periph[12])) |
>         CMU_ADMA_CH13_REQ_IDX(hal_dma_periph_2_idx(bes2003_audma_fifo_periph[13])) |
>         CMU_ADMA_CH14_REQ_IDX(hal_dma_periph_2_idx(bes2003_audma_fifo_periph[14]));
2138,2139c2845,2846
<         // i2s1
<         CMU_ADMA_CH15_REQ_IDX(19);
---
>         CMU_ADMA_CH15_REQ_IDX(hal_dma_periph_2_idx(bes2003_audma_fifo_periph[15]));
> 
2141,2148c2848,2852
<         // flash
<         CMU_GDMA_CH0_REQ_IDX(20) |
<         // sdmmc
<         CMU_GDMA_CH1_REQ_IDX(21) |
<         // i2c0
<         CMU_GDMA_CH2_REQ_IDX(22) | CMU_GDMA_CH3_REQ_IDX(23) |
<         // spi
<         CMU_GDMA_CH4_REQ_IDX(24);
---
>         CMU_GDMA_CH0_REQ_IDX(hal_dma_periph_2_idx(bes2003_gpdma_fifo_periph[0])) |
>         CMU_GDMA_CH1_REQ_IDX(hal_dma_periph_2_idx(bes2003_gpdma_fifo_periph[1])) |
>         CMU_GDMA_CH2_REQ_IDX(hal_dma_periph_2_idx(bes2003_gpdma_fifo_periph[2])) |
>         CMU_GDMA_CH3_REQ_IDX(hal_dma_periph_2_idx(bes2003_gpdma_fifo_periph[3])) |
>         CMU_GDMA_CH4_REQ_IDX(hal_dma_periph_2_idx(bes2003_gpdma_fifo_periph[4]));
2150,2155c2854,2858
<         // spi
<         CMU_GDMA_CH5_REQ_IDX(25) |
<         // spilcd
<         CMU_GDMA_CH6_REQ_IDX(26) | CMU_GDMA_CH7_REQ_IDX(27) |
<         // uart0
<         CMU_GDMA_CH8_REQ_IDX(28) | CMU_GDMA_CH9_REQ_IDX(29);
---
>         CMU_GDMA_CH5_REQ_IDX(hal_dma_periph_2_idx(bes2003_gpdma_fifo_periph[5])) |
>         CMU_GDMA_CH6_REQ_IDX(hal_dma_periph_2_idx(bes2003_gpdma_fifo_periph[6])) |
>         CMU_GDMA_CH7_REQ_IDX(hal_dma_periph_2_idx(bes2003_gpdma_fifo_periph[7])) |
>         CMU_GDMA_CH8_REQ_IDX(hal_dma_periph_2_idx(bes2003_gpdma_fifo_periph[8])) |
>         CMU_GDMA_CH9_REQ_IDX(hal_dma_periph_2_idx(bes2003_gpdma_fifo_periph[9]));
2157,2162c2860,2864
<         // uart1
<         CMU_GDMA_CH10_REQ_IDX(30) | CMU_GDMA_CH11_REQ_IDX(31) |
<         // i2c1
<         CMU_GDMA_CH12_REQ_IDX(32) | CMU_GDMA_CH13_REQ_IDX(33) |
<         // uart2
<         CMU_GDMA_CH14_REQ_IDX(34);
---
>         CMU_GDMA_CH10_REQ_IDX(hal_dma_periph_2_idx(bes2003_gpdma_fifo_periph[10])) |
>         CMU_GDMA_CH11_REQ_IDX(hal_dma_periph_2_idx(bes2003_gpdma_fifo_periph[11])) |
>         CMU_GDMA_CH12_REQ_IDX(hal_dma_periph_2_idx(bes2003_gpdma_fifo_periph[12])) |
>         CMU_GDMA_CH13_REQ_IDX(hal_dma_periph_2_idx(bes2003_gpdma_fifo_periph[13])) |
>         CMU_GDMA_CH14_REQ_IDX(hal_dma_periph_2_idx(bes2003_gpdma_fifo_periph[14]));
2164,2165c2866,2878
<         // uart2
<         CMU_GDMA_CH15_REQ_IDX(35);
---
>         CMU_GDMA_CH15_REQ_IDX(hal_dma_periph_2_idx(bes2003_gpdma_fifo_periph[15]));
> }
> 
> void BOOT_TEXT_FLASH_LOC hal_cmu_module_init_state(void)
> {
>     aoncmu->CLK_OUT = AON_CMU_EN_CLK_DCDC0 | AON_CMU_CFG_DIV_DCDC(1);
>     aoncmu->CODEC_DIV = (aoncmu->CODEC_DIV & ~AON_CMU_SEL_AON_OSCX2) | AON_CMU_SEL_AON_OSC;
>     // Slow down PMU fast clock
>     //aoncmu->CLK_OUT = (aoncmu->CLK_OUT & ~(AON_CMU_BYPASS_DIV_DCDC | AON_CMU_CFG_DIV_DCDC_MASK)) | AON_CMU_CFG_DIV_DCDC(2);
> 
>     hal_cmu_sram_init();
> 
>     hal_cmu_dma_req_init();
2168,2172c2881,2888
<     cmu->ORESET_SET = SYS_ORST_USB | SYS_ORST_SDMMC | SYS_ORST_WDT | SYS_ORST_TIMER2 |
<         SYS_ORST_I2C0 | SYS_ORST_I2C1 | SYS_ORST_SPI | SYS_ORST_SLCD | SYS_ORST_SPI_PHY |
<         SYS_ORST_UART0 | SYS_ORST_UART1 | SYS_ORST_UART2 | SYS_ORST_I2S0 | SYS_ORST_SPDIF0 | SYS_ORST_PCM |
<         SYS_ORST_USB32K | SYS_ORST_I2S1;
<     cmu->PRESET_SET = SYS_PRST_WDT | SYS_PRST_TIMER2 | SYS_PRST_I2C0 | SYS_PRST_I2C1 |
---
>     cmu->ORESET_SET = SYS_ORST_USB | SYS_ORST_USB32K | SYS_ORST_PSRAM1G | SYS_ORST_PSRAM200 | SYS_ORST_SDMMC |
>         SYS_ORST_WDT | SYS_ORST_TIMER2 | SYS_ORST_I2C0 | SYS_ORST_I2C1 | SYS_ORST_I2C2 | SYS_ORST_SPI | SYS_ORST_SLCD | SYS_ORST_SPI_PHY |
> #ifndef ARM_CMNS
>         SYS_ORST_UART0 |
> #endif
>         SYS_ORST_UART1 | SYS_ORST_UART2 | SYS_ORST_UART3 | SYS_ORST_PCM | SYS_ORST_I2S0 | SYS_ORST_I2S1 |
>         SYS_ORST_SPDIF0 | SYS_ORST_A7 | SYS_ORST_TSF | SYS_ORST_WDT_AP | SYS_ORST_TIMER0_AP | SYS_ORST_TIMER1_AP | SYS_ORST_FLASH1;
>     cmu->PRESET_SET = SYS_PRST_WDT | SYS_PRST_TIMER2 | SYS_PRST_I2C0 | SYS_PRST_I2C1 | SYS_PRST_I2C2 | SYS_PRST_IR |
2174,2183c2890,2913
<         SYS_PRST_UART0 | SYS_PRST_UART1 | SYS_PRST_UART2 |
<         SYS_PRST_PCM | SYS_PRST_I2S0 | SYS_PRST_SPDIF0 | SYS_PRST_I2S1 | SYS_PRST_BCM;
<     cmu->HRESET_SET = SYS_HRST_SDMMC | SYS_HRST_USBC | SYS_HRST_CODEC | SYS_HRST_FFT |
<         SYS_HRST_USBH | SYS_HRST_SENSOR_HUB | SYS_HRST_BT_DUMP | SYS_HRST_CP | SYS_HRST_BCM | SYS_HRST_ICACHE0;
< 
<     cmu->OCLK_DISABLE = SYS_OCLK_USB | SYS_OCLK_SDMMC | SYS_OCLK_WDT | SYS_OCLK_TIMER2 |
<         SYS_OCLK_I2C0 | SYS_OCLK_I2C1 | SYS_OCLK_SPI | SYS_OCLK_SLCD | SYS_OCLK_SPI_PHY |
<         SYS_OCLK_UART0 | SYS_OCLK_UART1 | SYS_OCLK_UART2 | SYS_OCLK_I2S0 | SYS_OCLK_SPDIF0 | SYS_OCLK_PCM |
<         SYS_OCLK_USB32K | SYS_OCLK_I2S1;
<     cmu->PCLK_DISABLE = SYS_PCLK_WDT | SYS_PCLK_TIMER2 | SYS_PCLK_I2C0 | SYS_PCLK_I2C1 |
---
> #ifndef ARM_CMNS
>         SYS_PRST_UART0 |
> #endif
>         SYS_PRST_UART1 | SYS_PRST_UART2 | SYS_PRST_UART3 |
>         SYS_PRST_PCM | SYS_PRST_I2S0 | SYS_PRST_I2S1 | SYS_PRST_SPDIF0 | SYS_PRST_TQWF | SYS_PRST_TQA7;
>     cmu->HRESET_SET = SYS_HRST_CORE1 | SYS_HRST_BCM | SYS_HRST_USBC | SYS_HRST_USBH | SYS_HRST_CODEC |
>         SYS_HRST_AX2H_A7 | SYS_HRST_PSRAM1G | SYS_HRST_PSRAM200 | SYS_HRST_BT_DUMP | SYS_HRST_WF_DUMP | SYS_HRST_SDMMC |
>         SYS_HRST_CHECKSUM | SYS_HRST_CRC | SYS_HRST_FLASH1;
>     cmu->XRESET_SET = SYS_XRST_DMA | SYS_XRST_NIC | SYS_XRST_IMEMLO | SYS_XRST_IMEMHI | SYS_XRST_PSRAM1G | SYS_XRST_PER |
>         SYS_XRST_PDBG | SYS_XRST_CORE0 | SYS_XRST_CORE1 | SYS_XRST_CORE2 | SYS_XRST_CORE3 | SYS_XRST_DBG | SYS_XRST_SCU |
>         SYS_XRST_DISPLAYX | SYS_XRST_DISPLAYH | SYS_XRST_CSI | SYS_XRST_DSI | SYS_XRST_PSRAM1GMX | SYS_XRST_GPV_MAIN | SYS_XRST_GPV_PSRAM1G;
>     cmu->APRESET_SET = SYS_APRST_BOOTREG | SYS_APRST_WDT| SYS_APRST_TIMER0 | SYS_APRST_TIMER1 | SYS_APRST_TQ | SYS_APRST_DAP |
>         SYS_APRST_DISPLAY | SYS_APRST_CSI;
>     cmu->QRESET_SET = SYS_QRST_DSI_32K | SYS_QRST_DSI_PN | SYS_QRST_DSI_TV | SYS_QRST_DSI_PIX |
>         SYS_QRST_DSI_DSI | SYS_QRST_CSI_LANE | SYS_QRST_CSI_PIX | SYS_QRST_CSI_LANG | SYS_QRST_IR;
> 
>     cmu->OCLK_DISABLE = SYS_OCLK_USB | SYS_OCLK_USB32K | SYS_OCLK_PSRAM1G | SYS_OCLK_PSRAM200 | SYS_OCLK_SDMMC |
>         SYS_OCLK_WDT | SYS_OCLK_TIMER2 | SYS_OCLK_I2C0 | SYS_OCLK_I2C1 | SYS_OCLK_I2C2 | SYS_OCLK_SPI | SYS_OCLK_SLCD | SYS_OCLK_SPI_PHY |
> #ifndef ARM_CMNS
>         SYS_OCLK_UART0 |
> #endif
>         SYS_OCLK_UART1 | SYS_OCLK_UART2 | SYS_OCLK_UART3 | SYS_OCLK_PCM | SYS_OCLK_I2S0 | SYS_OCLK_I2S1 |
>         SYS_OCLK_SPDIF0 | SYS_OCLK_A7 | SYS_OCLK_TSF | SYS_OCLK_WDT_AP | SYS_OCLK_TIMER0_AP | SYS_OCLK_TIMER1_AP | SYS_OCLK_FLASH1;
>     cmu->PCLK_DISABLE = SYS_PCLK_WDT | SYS_PCLK_TIMER2 | SYS_PCLK_I2C0 | SYS_PCLK_I2C1 | SYS_PCLK_I2C2 | SYS_PCLK_IR |
2185,2197c2915,2942
<         SYS_PCLK_UART0 | SYS_PCLK_UART1 | SYS_PCLK_UART2 |
<         SYS_PCLK_PCM | SYS_PCLK_I2S0 | SYS_PCLK_SPDIF0 | SYS_PCLK_I2S1 | SYS_PCLK_BCM;
<     cmu->HCLK_DISABLE = SYS_HCLK_SDMMC | SYS_HCLK_USBC | SYS_HCLK_CODEC | SYS_HCLK_FFT |
<         SYS_HCLK_USBH | SYS_HCLK_SENSOR_HUB | SYS_HCLK_BT_DUMP | SYS_HCLK_CP | SYS_HCLK_BCM | SYS_HCLK_ICACHE0;
< 
<     aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_PLL_CODEC_DISABLE | AON_CMU_EN_CLK_CODEC_HCLK_DISABLE | AON_CMU_EN_CLK_CODEC_DISABLE |
<         AON_CMU_EN_CLK_CODEC_IIR_DISABLE | AON_CMU_EN_CLK_PLL_BT_DISABLE |
<         AON_CMU_EN_CLK_60M_BT_DISABLE | AON_CMU_EN_CLK_OSCX2_BT_DISABLE | AON_CMU_EN_CLK_OSC_BT_DISABLE |
<         AON_CMU_EN_CLK_32K_BT_DISABLE | AON_CMU_EN_CLK_PLL_PER_DISABLE;
< 
<     aoncmu->RESET_SET = AON_CMU_ARESETN_SET(AON_ARST_PWM) |
<         AON_CMU_ORESETN_SET(AON_ORST_PWM0 | AON_ORST_PWM1 | AON_ORST_PWM2 | AON_ORST_PWM3) |
<         AON_CMU_SOFT_RSTN_CODEC_SET | AON_CMU_SOFT_RSTN_BT_SET | AON_CMU_SOFT_RSTN_BTCPU_SET;
---
> #ifndef ARM_CMNS
>         SYS_PCLK_UART0 |
> #endif
>         SYS_PCLK_UART1 | SYS_PCLK_UART2 | SYS_PCLK_UART3 |
>         SYS_PCLK_PCM | SYS_PCLK_I2S0 | SYS_PCLK_I2S1 | SYS_PCLK_SPDIF0 | SYS_PCLK_TQWF | SYS_PCLK_TQA7;
>     cmu->HCLK_DISABLE = SYS_HCLK_CORE1 | SYS_HCLK_BCM | SYS_HCLK_USBC | SYS_HCLK_USBH | SYS_HCLK_CODEC |
>         SYS_HCLK_AX2H_A7 | SYS_HCLK_PSRAM1G | SYS_HCLK_PSRAM200 | SYS_HCLK_BT_DUMP | SYS_HCLK_WF_DUMP | SYS_HCLK_SDMMC |
>         SYS_HCLK_CHECKSUM | SYS_HCLK_CRC | SYS_HCLK_FLASH1;
>     cmu->XCLK_DISABLE = SYS_XCLK_DMA | SYS_XCLK_NIC | SYS_XCLK_IMEMLO | SYS_XCLK_IMEMHI | SYS_XCLK_PSRAM1G | SYS_XCLK_PER |
>         SYS_XCLK_PDBG | SYS_XCLK_CORE0 | SYS_XCLK_CORE1 | SYS_XCLK_CORE2 | SYS_XCLK_CORE3 | SYS_XCLK_DBG | SYS_XCLK_SCU |
>         SYS_XCLK_DISPLAYX | SYS_XCLK_DISPLAYH | SYS_XCLK_CSI | SYS_XCLK_DSI | SYS_XCLK_PSRAM1GMX | SYS_XCLK_GPV_MAIN | SYS_XCLK_GPV_PSRAM1G;;
>     cmu->APCLK_DISABLE = SYS_APCLK_BOOTREG | SYS_APCLK_WDT| SYS_APCLK_TIMER0 | SYS_APCLK_TIMER1 | SYS_APCLK_TQ | SYS_APCLK_DAP |
>         SYS_APCLK_DISPLAY | SYS_APCLK_CSI;
>     cmu->QCLK_DISABLE = SYS_QCLK_DSI_32K | SYS_QCLK_DSI_PN | SYS_QCLK_DSI_TV | SYS_QCLK_DSI_PIX |
>         SYS_QCLK_DSI_DSI | SYS_QCLK_CSI_LANE | SYS_QCLK_CSI_PIX | SYS_QCLK_CSI_LANG | SYS_QCLK_IR;
> 
>     aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_CODEC_DISABLE | AON_CMU_EN_CLK_CODECIIR_DISABLE | AON_CMU_EN_CLK_CODECRS0_DISABLE |
>         AON_CMU_EN_CLK_CODECRS1_DISABLE | AON_CMU_EN_CLK_CODECHCLK_DISABLE | AON_CMU_EN_CLK_VAD32K_DISABLE |
>         AON_CMU_EN_CLK_BT_DISABLE | AON_CMU_EN_CLK_WF_DISABLE;
> 
>     aoncmu->RESET_SET = AON_CMU_ARESETN_SET(AON_ARST_PWM | AON_ARST_PWM1) |
>         AON_CMU_ORESETN_SET(AON_ORST_PWM0 | AON_ORST_PWM1 | AON_ORST_PWM2 | AON_ORST_PWM3 |
>             AON_ORST_PWM4 | AON_ORST_PWM5 | AON_ORST_PWM6 | AON_ORST_PWM7 | AON_ORST_BTAON);
> 
>     aoncmu->SOFT_RSTN_SET = AON_CMU_SOFT_RSTN_CODEC_SET |
>         AON_CMU_SOFT_RSTN_A7_SET | AON_CMU_SOFT_RSTN_A7CPU_SET |
>         AON_CMU_SOFT_RSTN_WF_SET | AON_CMU_SOFT_RSTN_WFCPU_SET |
>         AON_CMU_SOFT_RSTN_BT_SET | AON_CMU_SOFT_RSTN_BTCPU_SET;
2200c2945
<         AON_CMU_MANUAL_OCLK_DISABLE(AON_OCLK_PWM0 | AON_OCLK_PWM1 | AON_OCLK_PWM2 | AON_OCLK_PWM3);
---
>         AON_CMU_MANUAL_OCLK_DISABLE(AON_OCLK_PWM0 | AON_OCLK_PWM1 | AON_OCLK_PWM2 | AON_OCLK_PWM3 | AON_OCLK_BTAON);
2203c2948
<         AON_ACLK_TIMER | AON_ACLK_PSC | AON_ACLK_IOMUX);
---
>         AON_ACLK_TIMER | AON_ACLK_IOMUX);
2205a2951,2953
>     aoncmu->MIPI_CLK &= ~(AON_CMU_EN_CLK_PIX_DSI | AON_CMU_EN_CLK_PIX_CSI | AON_CMU_POL_CLK_DSI_IN |
>         AON_CMU_POL_CLK_CSI_IN);
> 
2210,2213d2957
< 
< #ifdef CORE_SLEEP_POWER_DOWN
<     hal_cmu_set_wakeup_pc((uint32_t)hal_sleep_core_power_up);
< #endif
2219c2963
<     // Never change EMA in best2300
---
>     // Never change EMA
2224c2968,2969
<     while ((cmu->WAKEUP_CLK_CFG & CMU_LPU_STATUS_26M) == 0);
---
>     while ((cmu->WAKEUP_CLK_CFG & (CMU_LPU_AUTO_SWITCH26 | CMU_LPU_STATUS_26M)) ==
>             CMU_LPU_AUTO_SWITCH26);
2229,2230c2974,2975
<     if ((cmu->WAKEUP_CLK_CFG & CMU_LPU_AUTO_SWITCH26) &&
<         (cmu->WAKEUP_CLK_CFG & CMU_LPU_STATUS_26M) == 0) {
---
>     if ((cmu->WAKEUP_CLK_CFG & (CMU_LPU_AUTO_SWITCH26 | CMU_LPU_STATUS_26M)) ==
>             CMU_LPU_AUTO_SWITCH26) {
2233,2234c2978,2979
<     if ((cmu->WAKEUP_CLK_CFG & CMU_LPU_AUTO_SWITCHPLL) &&
<         (cmu->WAKEUP_CLK_CFG & CMU_LPU_STATUS_PLL) == 0) {
---
>     if ((cmu->WAKEUP_CLK_CFG & (CMU_LPU_AUTO_SWITCHPLL | CMU_LPU_STATUS_PLL)) ==
>             CMU_LPU_AUTO_SWITCHPLL) {
2260a3006,3007
>     lpu_clk = cmu->WAKEUP_CLK_CFG;
>     lpu_clk &= ~(CMU_LPU_EN_MCU | CMU_LPU_EN_A7 | CMU_LPU_AUTO_SWITCHPLL | CMU_LPU_AUTO_SWITCH26);
2263c3010
<         lpu_clk = CMU_LPU_AUTO_SWITCH26;
---
>         lpu_clk |= CMU_LPU_EN_MCU | CMU_LPU_EN_A7 | CMU_LPU_AUTO_SWITCH26;
2265c3012
<         lpu_clk = CMU_LPU_AUTO_SWITCHPLL | CMU_LPU_AUTO_SWITCH26;
---
>         lpu_clk |= CMU_LPU_EN_MCU | CMU_LPU_EN_A7 | CMU_LPU_AUTO_SWITCHPLL | CMU_LPU_AUTO_SWITCH26;
2267d3013
<         lpu_clk = 0;
2274,2276c3020,3021
<         cmu->HCLK_MODE &= ~(SYS_HCLK_MCU | SYS_HCLK_ROM0 | SYS_HCLK_ROM1 | SYS_HCLK_ROM2 |
<             SYS_HCLK_RAM0 | SYS_HCLK_RAM1 | SYS_HCLK_RAM2 | SYS_HCLK_RAMRET | SYS_HCLK_RAM3 |
<             SYS_HCLK_RAM4 | SYS_HCLK_RAM5 | SYS_HCLK_RAM6);
---
>         cmu->HCLK_MODE &= ~(SYS_HCLK_CORE0 | SYS_HCLK_ROM0 | SYS_HCLK_RAM0 | SYS_HCLK_RAM1 |
>             SYS_HCLK_RAM2 | SYS_HCLK_RAM3 | SYS_HCLK_RAM4 | SYS_HCLK_RAM5);
2278c3023
<         aoncmu->CLK_SELECT |= AON_CMU_LPU_AUTO_SWITCH26;
---
>         aoncmu->CODEC_DIV |= AON_CMU_LPU_AUTO_SWITCH26;
2281c3026
<         aoncmu->CLK_SELECT &= ~AON_CMU_LPU_AUTO_SWITCH26;
---
>         aoncmu->CODEC_DIV &= ~AON_CMU_LPU_AUTO_SWITCH26;
2284c3029
<     cmu->WAKEUP_CLK_CFG = CMU_TIMER_WT26(timer_26m) | CMU_TIMER_WTPLL(0) | lpu_clk;
---
>     lpu_clk |= CMU_TIMER_WT26(timer_26m);
2285a3031
>         lpu_clk |= CMU_TIMER_WTPLL(timer_pll);
2287,2370c3033,3036
<         cmu->WAKEUP_CLK_CFG = CMU_TIMER_WT26(timer_26m) | CMU_TIMER_WTPLL(timer_pll) | lpu_clk;
<     }
<     return 0;
< }
< 
< #ifdef CORE_SLEEP_POWER_DOWN
< 
< static int SRAM_TEXT_LOC hal_cmu_lpu_sleep_pd(void)
< {
<     uint32_t start;
<     uint32_t timeout;
<     uint32_t saved_hclk;
<     uint32_t saved_oclk;
<     uint32_t saved_top_clk;
<     uint32_t saved_clk_cfg;
<     uint32_t saved_periph_clk;
<     uint32_t saved_sys_div;
<     uint32_t saved_uart_clk;
<     uint32_t saved_codec_div;
<     uint32_t pll_locked;
<     uint32_t saved_cpu_regs[50];
<     register uint32_t sp asm("sp");
<     uint32_t stack_limit;
< 
< #ifdef ROM_BUILD
<     extern uint32_t __rom_StackLimit[];
<     stack_limit = (uint32_t)__rom_StackLimit;
< #else
<     extern uint32_t __StackLimit[];
<     stack_limit = (uint32_t)__StackLimit;
< #endif
<     if (sp < stack_limit + 20 * 4) {
<         do {
<             asm volatile("nop; nop; nop; nop");
<         } while (1);
<     }
< 
<     NVIC_PowerDownSleep(saved_cpu_regs, ARRAY_SIZE(saved_cpu_regs));
< 
<     saved_hclk = cmu->HCLK_ENABLE;
<     saved_oclk = cmu->OCLK_ENABLE;
<     saved_periph_clk = cmu->PERIPH_CLK;
<     saved_sys_div = cmu->SYS_DIV;
<     saved_uart_clk = cmu->UART_CLK;
<     saved_codec_div = aoncmu->CODEC_DIV;
< 
<     saved_top_clk = aoncmu->TOP_CLK_ENABLE;
<     saved_clk_cfg = cmu->SYS_CLK_ENABLE;
< 
<     // Switch VAD clock to AON and disable codec HCLK
<     aoncmu->CODEC_DIV |= AON_CMU_SEL_CODEC_HCLK_AON;
<     aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_CODEC_HCLK_DISABLE;
< 
<     // Disable memory/flash clock
<     cmu->OCLK_DISABLE = SYS_OCLK_FLASH;
<     cmu->HCLK_DISABLE = SYS_HCLK_FLASH;
< 
< #ifndef ROM_BUILD
<     // Reset pll div if pll is enabled
<     if (saved_top_clk & AON_CMU_PU_PLLAUD_ENABLE) {
<         pmu_pll_div_reset_set(HAL_CMU_PLL_AUD);
<     }
<     if (saved_top_clk & AON_CMU_PU_PLLBB_ENABLE) {
<         pmu_pll_div_reset_set(HAL_CMU_PLL_USB);
<     }
< #endif
< 
<     // Switch system freq to 26M
<     cmu->SYS_CLK_ENABLE = CMU_SEL_OSC_SYS_ENABLE;
<     cmu->SYS_CLK_DISABLE = CMU_SEL_OSCX2_SYS_DISABLE | CMU_SEL_PLL_SYS_DISABLE;
<     cmu->SYS_CLK_DISABLE = CMU_RSTN_DIV_SYS_DISABLE;
< 
<     // Shutdown PLLs
<     if (saved_top_clk & AON_CMU_PU_PLLAUD_ENABLE) {
<         aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_TOP_PLLAUD_DISABLE;
<         aoncmu->TOP_CLK_DISABLE = AON_CMU_PU_PLLAUD_DISABLE;
<     }
<     if (saved_top_clk & AON_CMU_PU_PLLBB_ENABLE) {
<         aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_TOP_PLLBB_DISABLE;
<         aoncmu->TOP_CLK_DISABLE = AON_CMU_PU_PLLBB_DISABLE;
<     }
<     if (saved_top_clk & AON_CMU_PU_PLLUSB_ENABLE) {
<         aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_TOP_PLLUSB_DISABLE;
<         aoncmu->TOP_CLK_DISABLE = AON_CMU_PU_PLLUSB_DISABLE;
---
>         cmu->WAKEUP_CLK_CFG = lpu_clk;
>     } else {
>         lpu_clk |= CMU_TIMER_WTPLL(0);
>         cmu->WAKEUP_CLK_CFG = lpu_clk;
2373,2414c3039,3040
<     // Set power down wakeup bootmode
<     aoncmu->BOOTMODE = (aoncmu->BOOTMODE | HAL_SW_BOOTMODE_POWER_DOWN_WAKEUP) & HAL_SW_BOOTMODE_MASK;
<     // Set AON_CMU clock to 32K
<     aoncmu->CODEC_DIV &= ~(AON_CMU_SEL_CLK_OSC | AON_CMU_SEL_CLK_OSCX2);
< 
<     hal_sleep_core_power_down();
< 
<     while ((cmu->WAKEUP_CLK_CFG & CMU_LPU_STATUS_26M) == 0);
< 
<     // Restore AON_CMU clock
<     aoncmu->CODEC_DIV = saved_codec_div;
<     // Clear power down wakeup bootmode
<     aoncmu->BOOTMODE = (aoncmu->BOOTMODE & ~HAL_SW_BOOTMODE_POWER_DOWN_WAKEUP) & HAL_SW_BOOTMODE_MASK;
< 
<     // Disable memory/flash clock
<     cmu->OCLK_DISABLE = SYS_OCLK_FLASH;
<     cmu->HCLK_DISABLE = SYS_HCLK_FLASH;
< 
<     // Restore PLLs
<     if (saved_top_clk & (AON_CMU_PU_PLLAUD_ENABLE | AON_CMU_PU_PLLUSB_ENABLE | AON_CMU_PU_PLLBB_ENABLE)) {
<         pll_locked = 0;
<         if (saved_top_clk & AON_CMU_PU_PLLAUD_ENABLE) {
<             aoncmu->TOP_CLK_ENABLE = AON_CMU_PU_PLLAUD_ENABLE;
<             pll_locked |= AON_CMU_LOCK_PLLAUD;
<         }
<         if (saved_top_clk & AON_CMU_PU_PLLBB_ENABLE) {
<             aoncmu->TOP_CLK_ENABLE = AON_CMU_PU_PLLBB_ENABLE;
<             pll_locked |= AON_CMU_LOCK_PLLBB;
<         }
<         if (saved_top_clk & AON_CMU_PU_PLLUSB_ENABLE) {
<             aoncmu->TOP_CLK_ENABLE = AON_CMU_PU_PLLUSB_ENABLE;
<             pll_locked |= AON_CMU_LOCK_PLLUSB;
<         }
< #ifndef ROM_BUILD
<         hal_sys_timer_delay_us(10);
<         // Clear pll div reset if pll is enabled
<         if (saved_top_clk & AON_CMU_PU_PLLAUD_ENABLE) {
<             pmu_pll_div_reset_clear(HAL_CMU_PLL_AUD);
<         }
<         if (saved_top_clk & AON_CMU_PU_PLLBB_ENABLE) {
<             pmu_pll_div_reset_clear(HAL_CMU_PLL_USB);
<         }
---
> #ifndef ARM_CMNS
>     hal_sec_init(); //need metal_id
2416,2436d3041
<         start = hal_sys_timer_get();
<         timeout = HAL_CMU_PLL_LOCKED_TIMEOUT;
<         while (//(aoncmu->CODEC_DIV & pll_locked) != pll_locked &&
<                 (hal_sys_timer_get() - start) < timeout);
<         if (saved_top_clk & AON_CMU_EN_CLK_TOP_PLLAUD_ENABLE) {
<             aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_TOP_PLLAUD_ENABLE;
<         }
<         if (saved_top_clk & AON_CMU_EN_CLK_TOP_PLLBB_ENABLE) {
<             aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_TOP_PLLBB_ENABLE;
<         }
<         if (saved_top_clk & AON_CMU_EN_CLK_TOP_PLLUSB_ENABLE) {
<             aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_TOP_PLLUSB_ENABLE;
<         }
<     }
< 
<     // Restore system freq
<     cmu->SYS_CLK_ENABLE = saved_clk_cfg &
<         (CMU_RSTN_DIV_FLS_ENABLE | CMU_RSTN_DIV_SYS_ENABLE);
<     cmu->SYS_CLK_ENABLE = saved_clk_cfg;
<     // The original system freq are at least 26M
<     //cmu->SYS_CLK_DISABLE = ~saved_clk_cfg;
2438,2460c3043,3046
<     cmu->PERIPH_CLK = saved_periph_clk;
<     cmu->SYS_DIV = saved_sys_div;
<     cmu->UART_CLK = saved_uart_clk;
< 
<     // Switch VAD clock to MCU and enable codec HCLK if it is on before entering sleep
<     //aoncmu->CODEC_DIV &= ~AON_CMU_SEL_CODEC_HCLK_AON;
<     aoncmu->TOP_CLK_ENABLE = saved_top_clk & AON_CMU_EN_CLK_CODEC_HCLK_ENABLE;
< 
<     int_lock();
< 
<     NVIC_PowerDownWakeup(saved_cpu_regs, ARRAY_SIZE(saved_cpu_regs));
< 
<     // TODO:
<     // 1) Restore hardware modules, e.g., timer, cache, flash, psram, dma, usb, uart, spi, i2c, sdmmc, codec
<     // 2) Recover system timer in rt_suspend() and rt_resume()
<     // 3) Dynamically select 32K sleep or power down sleep
< 
<     if (saved_oclk & SYS_OCLK_FLASH) {
<         // Enable memory/flash clock
<         cmu->HCLK_ENABLE = saved_hclk;
<         cmu->OCLK_ENABLE = saved_oclk;
<         // Wait until memory/flash clock ready
<         hal_sys_timer_delay_us(2);
---
>     if (hal_get_chip_metal_id() >= HAL_CHIP_METAL_ID_4) {
>         cmu->CMU_REMAP = CMU_REMAP(0xF); //psram cache and flash cache
>     } else {
>         cmu->CMU_REMAP = CMU_REMAP(0xC); //psram cache
2466,2467d3051
< #endif
< 
2474c3058
<         //    wait 4 (at least 2) cycles of 32K clock, or 3248 cycles of 26M clock
---
>         //    Wait 4 (at least 2) cycles of 32K clock, or 3248 cycles of 26M clock.
2476,2489c3060,3063
<         //    No consecutive RAM access is allowed (all instructions must be 16-bit and must have no data access)
<         asm volatile (
<             "wfi;"
<             "movs.n r0, #0x3;"
<             "lsls r0, #8;"
<             "adds.n r0, #0x2c;"
<             "1:;"
<             "nop;"
<             "nop;"
<             "subs r0, 1;"
<             "bne.n 1b;"
<             :
<             :
<             : "r0", "cc" );
---
>         //    No consecutive RAM access is allowed.
>         //    This is related to instruction width/alignment, pipeline state, branch prediction state, etc.
>         //    Unfortunately, it is too hard to control all of these, especially on M33.
>         __WFI();
2495c3069
< static int SRAM_TEXT_LOC hal_cmu_lpu_sleep_normal(enum HAL_CMU_LPU_SLEEP_MODE_T mode)
---
> int SRAM_TEXT_LOC hal_cmu_lpu_sleep(enum HAL_CMU_LPU_SLEEP_MODE_T mode)
2499,2501c3073
<     uint32_t saved_hclk;
<     uint32_t saved_oclk;
<     uint32_t saved_top_clk;
---
>     uint32_t saved_pll_cfg;
2503a3076
>     uint32_t saved_top_clk;
2505,2510c3078,3079
<     bool pd_aud_pll;
<     bool pd_bb_pll;
<     bool wait_pll_locked;
< 
<     pd_aud_pll = true;
<     pd_bb_pll = true;
---
>     uint32_t saved_hclk;
>     uint32_t saved_oclk;
2512,2513d3080
<     saved_hclk = cmu->HCLK_ENABLE;
<     saved_oclk = cmu->OCLK_ENABLE;
2515a3083
>     saved_pll_cfg = aoncmu->PLL_ENABLE;
2516a3085,3086
>     saved_hclk = cmu->HCLK_ENABLE;
>     saved_oclk = cmu->OCLK_ENABLE;
2517a3088,3089
>     // Switch VAD clock to AON and disable codec HCLK
>     aoncmu->CODEC_DIV |= AON_CMU_SEL_CODECHCLK_MCU;
2519c3091
<         wakeup_cfg = cmu->WAKEUP_CLK_CFG;
---
>         aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_CODECHCLK_DISABLE;
2521,2527c3093,3094
<         wakeup_cfg = 0;
<         if (pll_user_map[HAL_CMU_PLL_AUD] & (1 << HAL_CMU_PLL_USER_AUD)) {
<             pd_aud_pll = false;
<         }
<         if (pll_user_map[HAL_CMU_PLL_USB] & (1 << HAL_CMU_PLL_USER_AUD)) {
<             pd_bb_pll = false;
<         }
---
>         // Avoid auto-gating OSC and OSCX2
>         aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_TOP_OSCX2_ENABLE | AON_CMU_EN_CLK_TOP_OSC_ENABLE;
2530,2531d3096
<     // Switch VAD clock to AON and disable codec HCLK
<     aoncmu->CODEC_DIV |= AON_CMU_SEL_CODEC_HCLK_AON;
2533c3098,3100
<         aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_CODEC_HCLK_DISABLE;
---
>         wakeup_cfg = cmu->WAKEUP_CLK_CFG;
>     } else {
>         wakeup_cfg = 0;
2536,2538c3103,3105
<     // Disable memory/flash clock
<     cmu->OCLK_DISABLE = SYS_OCLK_FLASH;
<     cmu->HCLK_DISABLE = SYS_HCLK_FLASH;
---
>     // Disable memory/flash freq
>     cmu->OCLK_DISABLE = SYS_OCLK_PSRAM1G | SYS_OCLK_PSRAM200 | SYS_OCLK_FLASH;
>     cmu->HCLK_DISABLE = SYS_HCLK_PSRAM1G | SYS_HCLK_PSRAM200 | SYS_HCLK_FLASH;
2542,2545c3109
<     if (pd_aud_pll && (saved_top_clk & AON_CMU_PU_PLLAUD_ENABLE)) {
<         pmu_pll_div_reset_set(HAL_CMU_PLL_AUD);
<     }
<     if (pd_bb_pll && (saved_top_clk & AON_CMU_PU_PLLBB_ENABLE)) {
---
>     if (saved_pll_cfg & AON_CMU_PU_PLLUSB_ENABLE) {
2547a3112,3123
>     if (saved_pll_cfg & AON_CMU_PU_PLLDDR_ENABLE) {
>         pmu_pll_div_reset_set(HAL_CMU_PLL_DDR);
>     }
>     if (saved_pll_cfg & AON_CMU_PU_PLLA7_ENABLE) {
>         pmu_pll_div_reset_set(HAL_CMU_PLL_DSP);
>     }
>     if (saved_pll_cfg & AON_CMU_PU_PLLBB_DIV_MCU_ENABLE) {
>         pmu_pll_div_reset_set(HAL_CMU_PLL_BB);
>     }
>     if (saved_pll_cfg & AON_CMU_PU_PLLBB_DIV_PS_ENABLE) {
>         pmu_pll_div_reset_set(HAL_CMU_PLL_BB_PSRAM);
>     }
2550a3127,3131
> #ifdef __ARM_ARCH_ISA_ARM
>     cmu->WAKEUP_MASK0 = GICDistributor->ISENABLER[0];
>     cmu->WAKEUP_MASK1 = GICDistributor->ISENABLER[1];
>     cmu->WAKEUP_MASK2 = GICDistributor->ISENABLER[2];
> #else
2552a3134,3135
>     cmu->WAKEUP_MASK2 = NVIC->ISER[2];
> #endif
2554,2557d3136
<     if (wakeup_cfg & CMU_LPU_AUTO_SWITCHPLL) {
<         // Do nothing
<         // Hardware will switch system freq to 32K and shutdown PLLs automatically
<     } else {
2559,2561c3138,3141
<         cmu->SYS_CLK_ENABLE = CMU_SEL_OSC_SYS_ENABLE;
<         cmu->SYS_CLK_DISABLE = CMU_SEL_OSCX2_SYS_DISABLE | CMU_SEL_PLL_SYS_DISABLE;
<         cmu->SYS_CLK_DISABLE = CMU_RSTN_DIV_SYS_DISABLE;
---
>     cmu->SYS_CLK_ENABLE = CMU_SEL_MCU_SLOW_ENABLE;
>     cmu->SYS_CLK_DISABLE = CMU_SEL_MCU_OSC_4_DISABLE | CMU_SEL_MCU_OSC_2_DISABLE |
>         CMU_SEL_MCU_OSCX4_DISABLE | CMU_SEL_MCU_FAST_DISABLE | CMU_SEL_MCU_PLL_DISABLE;
>     cmu->SYS_CLK_DISABLE = CMU_RSTN_DIV_MCU_DISABLE;
2563,2565c3143,3153
<         if (pd_aud_pll && (saved_top_clk & AON_CMU_PU_PLLAUD_ENABLE)) {
<             aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_TOP_PLLAUD_DISABLE;
<             aoncmu->TOP_CLK_DISABLE = AON_CMU_PU_PLLAUD_DISABLE;
---
>     if (saved_pll_cfg & AON_CMU_PU_PLLUSB_ENABLE) {
>         aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_TOP_PLLUSB_DISABLE;
>         aoncmu->PLL_DISABLE = AON_CMU_PU_PLLUSB_DISABLE;
>     }
>     if (saved_pll_cfg & AON_CMU_PU_PLLDDR_ENABLE) {
>         aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_TOP_PLLDDR_DISABLE;
>         aoncmu->PLL_DISABLE = AON_CMU_PU_PLLDDR_DISABLE;
>     }
>     if (saved_pll_cfg & AON_CMU_PU_PLLA7_ENABLE) {
>         aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_TOP_PLLA7_DISABLE;
>         aoncmu->PLL_DISABLE = AON_CMU_PU_PLLA7_DISABLE;
2567c3155
<         if (pd_bb_pll && (saved_top_clk & AON_CMU_PU_PLLBB_ENABLE)) {
---
>     if (saved_pll_cfg & AON_CMU_PU_PLLBB_DIV_MCU_ENABLE) {
2569c3157
<             aoncmu->TOP_CLK_DISABLE = AON_CMU_PU_PLLBB_DISABLE;
---
>         aoncmu->PLL_DISABLE = AON_CMU_PU_PLLBB_DIV_MCU_DISABLE;
2571,2573c3159,3168
<         if (saved_top_clk & AON_CMU_PU_PLLUSB_ENABLE) {
<             aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_TOP_PLLUSB_DISABLE;
<             aoncmu->TOP_CLK_DISABLE = AON_CMU_PU_PLLUSB_DISABLE;
---
>     if (saved_pll_cfg & AON_CMU_PU_PLLBB_DIV_PS_ENABLE) {
>         aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_TOP_PLLBB_PS_DISABLE;
>         aoncmu->PLL_DISABLE = AON_CMU_PU_PLLBB_DIV_PS_DISABLE;
>     }
>     if (saved_pll_cfg & AON_CMU_PU_PLLBB_ENABLE) {
>         aoncmu->PLL_DISABLE = AON_CMU_PU_PLLBB_DISABLE;
>     }
>     if (saved_pll_cfg & AON_CMU_PU_OSCX4_ENABLE) {
>         aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_TOP_OSCX4_DISABLE;
>         aoncmu->PLL_DISABLE = AON_CMU_PU_OSCX4_DISABLE;
2574a3170,3174
> 
>     if (wakeup_cfg & CMU_LPU_AUTO_SWITCHPLL) {
>         // Do nothing
>         // Hardware will switch system freq to 32K and shutdown PLLs automatically
>     } else {
2580c3180
<             aoncmu->CODEC_DIV &= ~(AON_CMU_SEL_CLK_OSC | AON_CMU_SEL_CLK_OSCX2);
---
>             aoncmu->CODEC_DIV &= ~(AON_CMU_SEL_AON_OSC | AON_CMU_SEL_AON_OSCX2);
2582c3182
<             cmu->SYS_CLK_DISABLE = CMU_SEL_OSC_SYS_DISABLE;
---
>             cmu->SYS_CLK_DISABLE = CMU_SEL_MCU_SLOW_DISABLE;
2595a3196
> #ifndef __ARM_ARCH_ISA_ARM
2600a3202
> #endif
2609,2620c3211
<         // !!! CAUTION !!!
<         // Hardware will switch system freq to PLL divider and enable PLLs automatically
< #ifndef ROM_BUILD
<         hal_sys_timer_delay_us(10);
<         // Clear pll div reset if pll is enabled
<         if (saved_top_clk & AON_CMU_PU_PLLAUD_ENABLE) {
<             pmu_pll_div_reset_clear(HAL_CMU_PLL_AUD);
<         }
<         if (saved_top_clk & AON_CMU_PU_PLLBB_ENABLE) {
<             pmu_pll_div_reset_clear(HAL_CMU_PLL_USB);
<         }
< #endif
---
>         // Hardware will switch system to PLL divider and enable PLLs automatically
2635c3226
<             cmu->SYS_CLK_ENABLE = CMU_SEL_OSC_SYS_ENABLE;
---
>             cmu->SYS_CLK_ENABLE = CMU_SEL_MCU_SLOW_ENABLE;
2638a3230,3231
>     }
> 
2641,2653c3234,3250
<         if (saved_top_clk & (AON_CMU_PU_PLLAUD_ENABLE | AON_CMU_PU_PLLUSB_ENABLE | AON_CMU_PU_PLLBB_ENABLE)) {
<             wait_pll_locked = false;
<             if (pd_aud_pll && (saved_top_clk & AON_CMU_PU_PLLAUD_ENABLE)) {
<                 aoncmu->TOP_CLK_ENABLE = AON_CMU_PU_PLLAUD_ENABLE;
<                 wait_pll_locked = true;
<             }
<             if (pd_bb_pll && (saved_top_clk & AON_CMU_PU_PLLBB_ENABLE)) {
<                 aoncmu->TOP_CLK_ENABLE = AON_CMU_PU_PLLBB_ENABLE;
<                 wait_pll_locked = true;
<             }
<             if (saved_top_clk & AON_CMU_PU_PLLUSB_ENABLE) {
<                 aoncmu->TOP_CLK_ENABLE = AON_CMU_PU_PLLUSB_ENABLE;
<                 wait_pll_locked = true;
---
>     if (saved_pll_cfg & AON_CMU_PU_PLLUSB_ENABLE) {
>         aoncmu->PLL_ENABLE = AON_CMU_PU_PLLUSB_ENABLE;
>     }
>     if (saved_pll_cfg & AON_CMU_PU_PLLDDR_ENABLE) {
>         aoncmu->PLL_ENABLE = AON_CMU_PU_PLLDDR_ENABLE;
>     }
>     if (saved_pll_cfg & AON_CMU_PU_PLLA7_ENABLE) {
>         aoncmu->PLL_ENABLE = AON_CMU_PU_PLLA7_ENABLE;
>     }
>     if (saved_pll_cfg & AON_CMU_PU_PLLBB_DIV_MCU_ENABLE) {
>         aoncmu->PLL_ENABLE = AON_CMU_PU_PLLBB_ENABLE | AON_CMU_PU_PLLBB_DIV_MCU_ENABLE;
>     }
>     if (saved_pll_cfg & AON_CMU_PU_PLLBB_DIV_PS_ENABLE) {
>         aoncmu->PLL_ENABLE = AON_CMU_PU_PLLBB_ENABLE | AON_CMU_PU_PLLBB_DIV_PS_ENABLE;
>     }
>     if (saved_pll_cfg & AON_CMU_PU_OSCX4_ENABLE) {
>         aoncmu->PLL_ENABLE = AON_CMU_PU_OSCX4_ENABLE;
2655d3251
<             if (wait_pll_locked) {
2657c3253
<                 hal_sys_timer_delay_us(10);
---
>     hal_sys_timer_delay_us(20);
2659,2662c3255
<                 if (pd_aud_pll && (saved_top_clk & AON_CMU_PU_PLLAUD_ENABLE)) {
<                     pmu_pll_div_reset_clear(HAL_CMU_PLL_AUD);
<                 }
<                 if (pd_bb_pll && (saved_top_clk & AON_CMU_PU_PLLBB_ENABLE)) {
---
>     if (saved_pll_cfg & AON_CMU_PU_PLLUSB_ENABLE) {
2665,2668c3258,3259
< #endif
<                 start = hal_sys_timer_get();
<                 timeout = HAL_CMU_PLL_LOCKED_TIMEOUT;
<                 while ((hal_sys_timer_get() - start) < timeout);
---
>     if (saved_pll_cfg & AON_CMU_PU_PLLDDR_ENABLE) {
>         pmu_pll_div_reset_clear(HAL_CMU_PLL_DDR);
2670,2671c3261,3262
<             if (pd_aud_pll && (saved_top_clk & AON_CMU_EN_CLK_TOP_PLLAUD_ENABLE)) {
<                 aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_TOP_PLLAUD_ENABLE;
---
>     if (saved_pll_cfg & AON_CMU_PU_PLLA7_ENABLE) {
>         pmu_pll_div_reset_clear(HAL_CMU_PLL_DSP);
2673,2674c3264,3268
<             if (pd_bb_pll && (saved_top_clk & AON_CMU_EN_CLK_TOP_PLLBB_ENABLE)) {
<                 aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_TOP_PLLBB_ENABLE;
---
>     if (saved_pll_cfg & AON_CMU_PU_PLLBB_DIV_MCU_ENABLE) {
>         pmu_pll_div_reset_clear(HAL_CMU_PLL_BB);
>     }
>     if (saved_pll_cfg & AON_CMU_PU_PLLBB_DIV_PS_ENABLE) {
>         pmu_pll_div_reset_clear(HAL_CMU_PLL_BB_PSRAM);
2676c3270,3272
<             if (saved_top_clk & AON_CMU_EN_CLK_TOP_PLLUSB_ENABLE) {
---
>     hal_sys_timer_delay_us(10);
> #endif
>     if (saved_pll_cfg & AON_CMU_PU_PLLUSB_ENABLE) {
2678a3275,3276
>     if (saved_pll_cfg & AON_CMU_PU_PLLDDR_ENABLE) {
>         aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_TOP_PLLDDR_ENABLE;
2679a3278,3288
>     if (saved_pll_cfg & AON_CMU_PU_PLLA7_ENABLE) {
>         aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_TOP_PLLA7_ENABLE;
>     }
>     if (saved_pll_cfg & AON_CMU_PU_PLLBB_DIV_MCU_ENABLE) {
>         aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_TOP_PLLBB_ENABLE;
>     }
>     if (saved_pll_cfg & AON_CMU_PU_PLLBB_DIV_PS_ENABLE) {
>         aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_TOP_PLLBB_PS_ENABLE;
>     }
>     if (saved_pll_cfg & AON_CMU_PU_OSCX4_ENABLE) {
>         aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_TOP_OSCX4_ENABLE;
2681d3289
< 
2683,2684c3291
<     cmu->SYS_CLK_ENABLE = saved_clk_cfg &
<         (CMU_RSTN_DIV_FLS_ENABLE | CMU_RSTN_DIV_SYS_ENABLE);
---
>     cmu->SYS_CLK_ENABLE = saved_clk_cfg & CMU_RSTN_DIV_MCU_ENABLE;
2690c3297
<     aoncmu->CODEC_DIV &= ~AON_CMU_SEL_CODEC_HCLK_AON;
---
>     aoncmu->CODEC_DIV &= ~AON_CMU_SEL_CODECHCLK_MCU;
2692c3299,3302
<         aoncmu->TOP_CLK_ENABLE = saved_top_clk & AON_CMU_EN_CLK_CODEC_HCLK_ENABLE;
---
>         aoncmu->TOP_CLK_ENABLE = saved_top_clk & AON_CMU_EN_CLK_CODECHCLK_ENABLE;
>     } else {
>         // Restore the original top clock settings
>         aoncmu->TOP_CLK_DISABLE = ~saved_top_clk;
2695c3305
<     if (saved_oclk & SYS_OCLK_FLASH) {
---
>     if (saved_oclk & (SYS_OCLK_PSRAM1G | SYS_OCLK_PSRAM200 | SYS_OCLK_FLASH)) {
2706,2715d3315
< int SRAM_TEXT_LOC hal_cmu_lpu_sleep(enum HAL_CMU_LPU_SLEEP_MODE_T mode)
< {
< #ifdef CORE_SLEEP_POWER_DOWN
<     if (mode == HAL_CMU_LPU_SLEEP_MODE_POWER_DOWN) {
<         return hal_cmu_lpu_sleep_pd();
<     }
< #endif
<     return hal_cmu_lpu_sleep_normal(mode);
< }
< 
2721,2726d3320
< SRAM_TEXT_LOC
< volatile uint32_t *hal_cmu_get_memsc_addr(void)
< {
<     return &aoncmu->MEMSC[0];
< }
< 
2729c3323,3325
<     aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_OSCX2_BT_ENABLE | AON_CMU_EN_CLK_OSC_BT_ENABLE | AON_CMU_EN_CLK_32K_BT_ENABLE;
---
>     aoncmu->MOD_CLK_ENABLE = AON_CMU_MANUAL_OCLK_ENABLE(AON_OCLK_BTAON);
>     aocmu_reg_update_wait();
>     aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_BT_ENABLE;
2735c3331,3332
<     aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_OSCX2_BT_DISABLE | AON_CMU_EN_CLK_OSC_BT_DISABLE | AON_CMU_EN_CLK_32K_BT_DISABLE;
---
>     aoncmu->MOD_CLK_DISABLE = AON_CMU_MANUAL_OCLK_DISABLE(AON_OCLK_BTAON);
>     aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_BT_DISABLE;
2740c3337,3338
<     aoncmu->RESET_SET = AON_CMU_SOFT_RSTN_BT_SET | AON_CMU_SOFT_RSTN_BTCPU_SET;
---
>     aoncmu->RESET_SET = AON_CMU_ORESETN_SET(AON_ORST_BTAON);
>     aoncmu->SOFT_RSTN_SET = AON_CMU_SOFT_RSTN_BT_SET | AON_CMU_SOFT_RSTN_BTCPU_SET;
2745c3343,3345
<     aoncmu->RESET_CLR = AON_CMU_SOFT_RSTN_BT_CLR | AON_CMU_SOFT_RSTN_BTCPU_CLR;
---
>     aoncmu->RESET_CLR = AON_CMU_ORESETN_CLR(AON_ORST_BTAON);
>     aocmu_reg_update_wait();
>     aoncmu->SOFT_RSTN_CLR = AON_CMU_SOFT_RSTN_BT_CLR | AON_CMU_SOFT_RSTN_BTCPU_CLR;
2753a3354,3553
> void hal_cmu_wifi_clock_enable(void)
> {
>     aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_CLK_WF_ENABLE;
>     aocmu_reg_update_wait();
> }
> 
> void hal_cmu_wifi_clock_disable(void)
> {
>     aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_CLK_WF_DISABLE;
> }
> 
> void hal_cmu_wifi_reset_set(void)
> {
>     aoncmu->SOFT_RSTN_SET = AON_CMU_SOFT_RSTN_WF_SET | AON_CMU_SOFT_RSTN_WFCPU_SET;
> }
> 
> void hal_cmu_wifi_reset_clear(void)
> {
>     aoncmu->SOFT_RSTN_CLR = AON_CMU_SOFT_RSTN_WF_CLR | AON_CMU_SOFT_RSTN_WFCPU_CLR;
>     aocmu_reg_update_wait();
> }
> 
> void BOOT_TEXT_FLASH_LOC hal_cmu_wlan_set_sleep_allow(uint32_t auto_mode)
> {
>     if (auto_mode) { //controlled by wifi sleep signal
>         aoncmu->RESERVED_0E8 = aoncmu->RESERVED_0E8 & (~((1<<4)|(1<<6)));
>     } else { //force allow cmu sleep
>         aoncmu->RESERVED_0E8 = (aoncmu->RESERVED_0E8 & (~((1<<5)|(1<<7)))) | ((1<<4)|(1<<6));
>     }
> }
> 
> static void GPV_init(void)
> {
> #ifdef GPV_MAIN_BASE
>     volatile uint32_t *gpv_ctrl_psram = (volatile uint32_t *)(GPV_MAIN_BASE+0x6000);
>     volatile uint32_t *gpv_ctrl_x2h = (volatile uint32_t *)(GPV_MAIN_BASE+0x7000);
>     gpv_ctrl_psram[17] |= 0x2; //0x50306044
>     gpv_ctrl_x2h[17] |= 0x2; //0x50307044
> #endif
> }
> 
> void hal_cmu_dsp_clock_enable(void)
> {
>     enum HAL_CMU_PLL_T dsp;
> #ifdef DSP_ENABLE
>     hal_psc_a7_enable();
> #endif
>     // DSP AXI clock divider defaults to 4 (div = reg_val + 2)
>     cmu->DSP_DIV = SET_BITFIELD(cmu->DSP_DIV, CMU_CFG_DIV_XCLK, 2);
>     cmu->XCLK_ENABLE = SYS_XCLK_DMA | SYS_XCLK_NIC | SYS_XCLK_IMEMLO | SYS_XCLK_IMEMHI | SYS_XCLK_PER |
>         SYS_XCLK_PDBG | SYS_XCLK_CORE0 | SYS_XCLK_CORE1 | SYS_XCLK_CORE2 | SYS_XCLK_CORE3 | SYS_XCLK_DBG | SYS_XCLK_SCU |
>         SYS_XCLK_GPV_MAIN;
>     cmu->APCLK_ENABLE = SYS_APCLK_BOOTREG | SYS_APCLK_WDT| SYS_APCLK_TIMER0 | SYS_APCLK_TIMER1 | SYS_APCLK_TQ | SYS_APCLK_DAP;
>     cmu->HCLK_ENABLE = SYS_HCLK_AX2H_A7;
> 
>     cmu->DSP_CFG0 |= CMU_CA7_DBGEN_MASK | CMU_CA7_SPIDEN_MASK | CMU_CA7_NIDEN_MASK | CMU_CA7_SPNIDEN_MASK;
> 
>     cmu->PERIPH_CLK |= CMU_A7_ALLIRQ_MASK;
>     cmu->DSP_CFG0 |= CMU_A7TOM33_IRQS_MASK(8);
> 
> #ifdef DSP_USE_BBPLL
>     dsp = HAL_CMU_PLL_BB;
> #elif defined(DSP_USE_USBPLL)
>     dsp = HAL_CMU_PLL_USB;
> #else
>     dsp = HAL_CMU_PLL_DSP;
> #endif
>     hal_cmu_dsp_select_pll(dsp);
>     hal_cmu_pll_enable(dsp, HAL_CMU_PLL_USER_DSP);
> 
>     hal_cmu_dsp_set_freq(HAL_CMU_FREQ_780M);
> 
> #ifdef DSP_ENABLE
>     hal_cmu_clock_enable(HAL_CMU_MOD_O_A7);
>     hal_cmu_clock_enable(HAL_CMU_MOD_O_WDT_AP);
>     hal_cmu_clock_enable(HAL_CMU_MOD_O_TIMER0_AP);
>     hal_cmu_clock_enable(HAL_CMU_MOD_O_TIMER1_AP);
> #ifndef ARM_CMNS
>     ///TODO: add cmse interface if trustzone is enabled
>     GPV_init();
> #endif
> #endif
> }
> 
> void hal_cmu_dsp_clock_disable(void)
> {
>     enum HAL_CMU_PLL_T dsp;
> 
>     hal_cmu_clock_disable(HAL_CMU_MOD_O_A7);
> 
> #ifdef DSP_USE_BBPLL
>     dsp = HAL_CMU_PLL_BB;
> #elif defined(DSP_USE_USBPLL)
>     dsp = HAL_CMU_PLL_USB;
> #else
>     dsp = HAL_CMU_PLL_DSP;
> #endif
>     hal_cmu_pll_disable(dsp, HAL_CMU_PLL_USER_DSP);
> 
>     cmu->XCLK_DISABLE = SYS_XCLK_DMA | SYS_XCLK_NIC | SYS_XCLK_IMEMLO | SYS_XCLK_IMEMHI | SYS_XCLK_PER |
>         SYS_XCLK_PDBG | SYS_XCLK_CORE0 | SYS_XCLK_CORE1 | SYS_XCLK_CORE2 | SYS_XCLK_CORE3 | SYS_XCLK_DBG | SYS_XCLK_SCU |
>         SYS_XCLK_GPV_MAIN;
>     cmu->APCLK_DISABLE = SYS_APCLK_BOOTREG | SYS_APCLK_WDT| SYS_APCLK_TIMER0 | SYS_APCLK_TIMER1 | SYS_APCLK_TQ | SYS_APCLK_DAP;
>     cmu->OCLK_DISABLE = SYS_OCLK_WDT_AP | SYS_OCLK_TIMER0_AP | SYS_OCLK_TIMER1_AP;
>     cmu->HCLK_DISABLE = SYS_HCLK_AX2H_A7;
> 
>     hal_psc_a7_disable();
> }
> 
> void hal_cmu_dsp_reset_set(void)
> {
>     aoncmu->SOFT_RSTN_SET = AON_CMU_SOFT_RSTN_A7_SET | AON_CMU_SOFT_RSTN_A7CPU_SET;
>     cmu->ORESET_SET = SYS_ORST_WDT_AP | SYS_ORST_TIMER0_AP | SYS_ORST_TIMER1_AP;
>     cmu->XRESET_SET = SYS_XRST_DMA | SYS_XRST_NIC | SYS_XRST_IMEMLO | SYS_XRST_IMEMHI | SYS_XRST_PER |
>         SYS_XRST_PDBG | SYS_XRST_CORE0 | SYS_XRST_CORE1 | SYS_XRST_CORE2 | SYS_XRST_CORE3 | SYS_XRST_DBG | SYS_XRST_SCU |
>         SYS_XRST_GPV_MAIN;
>     cmu->APRESET_SET = SYS_APRST_BOOTREG | SYS_APRST_WDT | SYS_APRST_TIMER0 | SYS_APRST_TIMER1 | SYS_APRST_TQ | SYS_APRST_DAP;
>     cmu->HRESET_SET = SYS_HRST_AX2H_A7;
> }
> 
> void hal_cmu_dsp_reset_clear(void)
> {
>     cmu->APRESET_CLR = SYS_APCLK_BOOTREG | SYS_APCLK_WDT| SYS_APCLK_TIMER0 | SYS_APCLK_TIMER1 | SYS_APCLK_TQ | SYS_APCLK_DAP;
>     cmu->XRESET_CLR = SYS_XRST_DMA | SYS_XRST_NIC | SYS_XRST_IMEMLO | SYS_XRST_IMEMHI | SYS_XRST_PER |
>         SYS_XRST_PDBG | SYS_XRST_CORE0 | SYS_XRST_CORE1 | SYS_XRST_CORE2 | SYS_XRST_CORE3 | SYS_XRST_DBG | SYS_XRST_SCU |
>         SYS_XRST_GPV_MAIN;
>     cmu->ORESET_CLR = SYS_ORST_WDT_AP | SYS_ORST_TIMER0_AP | SYS_ORST_TIMER1_AP;
>     cmu->HRESET_CLR = SYS_HRST_AX2H_A7;
>     aoncmu->SOFT_RSTN_CLR = AON_CMU_SOFT_RSTN_A7_CLR;
>     aocmu_reg_update_wait();
> }
> 
> void hal_cmu_dsp_reset_hold(void)
> {
>     aoncmu->SOFT_RSTN_SET = AON_CMU_SOFT_RSTN_A7_SET | AON_CMU_SOFT_RSTN_A7CPU_SET;
>     cmu->HRESET_SET = SYS_HRST_AX2H_A7 | SYS_HRST_PSRAM1G;
>     cmu->ORESET_SET = SYS_ORST_PSRAM1G;
>     cmu->ORESET_SET = SYS_ORST_WDT_AP | SYS_ORST_TIMER1_AP;
> }
> 
> void hal_cmu_dsp_reset_release(void)
> {
>     cmu->ORESET_CLR = SYS_ORST_WDT_AP | SYS_ORST_TIMER1_AP;
>     cmu->ORESET_CLR = SYS_ORST_PSRAM1G;
>     cmu->HRESET_CLR = SYS_HRST_AX2H_A7 | SYS_HRST_PSRAM1G;
>     aoncmu->SOFT_RSTN_CLR = AON_CMU_SOFT_RSTN_A7_CLR;
>     aocmu_reg_update_wait();
> }
> 
> void hal_cmu_dsp_init_boot_reg(uint32_t entry)
> {
>     int i;
>     volatile uint32_t *boot = (volatile uint32_t *)DSP_BOOT_REG;
> 
>     // Unlock
>     boot[32] = 0xCAFE0001;
>     __DMB();
> 
>     for (i = 0; i < 8; i++) {
>         // ldr pc, [pc, #24]
>         boot[0 + i] = 0xE59FF018;
>         // Init_Handler
>         boot[8 + i] = 0x00000040;
>     }
>     // b   40
>     boot[16] = 0xEAFFFFFE;
> 
>     // Update reset handler
>     boot[8] = entry;
> 
>     // Lock
>     __DMB();
>     boot[32] = 0xCAFE0000;
>     __DMB();
> }
> 
> void hal_cmu_dsp_start_cpu(void)
> {
>     hal_cmu_dsp_set_freq(HAL_CMU_FREQ_156M);//div 5
>     aoncmu->SOFT_RSTN_CLR = AON_CMU_SOFT_RSTN_A7CPU_CLR;
> }
> 
> void hal_cmu_dsp_stop_cpu(void)
> {
>     uint32_t lock;
>     lock = int_lock();
> #ifdef PSRAMUHS_ENABLE
>     hal_psramuhs_hold();
> #endif
>     hal_cmu_dsp_reset_hold();
>     //hal_cmu_dsp_clock_disable();
> 
> #ifdef PSRAMUHS_ENABLE
>     //hal_cmu_dsp_clock_enable();
>     hal_cmu_dsp_reset_release();
>     hal_psramuhs_release();
> #endif
>     int_unlock(lock);
> }
> 
2765a3566,3574
>     struct CP_STARTUP_CFG_T * cp_cfg;
>     uint32_t cfg_addr;
> 
>     // Use (sp - 128) as the default vector. The Address must aligned to 128-byte boundary.
>     cfg_addr = (sp - (1 << 7)) & ~((1 << 7) - 1);
> 
>     cmu->CP_VTOR = cfg_addr;
>     cp_cfg = (struct CP_STARTUP_CFG_T *)cfg_addr;
> 
2768c3577
<     cp_cfg->entry = entry;
---
>     cp_entry = entry;
2782c3591,3739
<     return cp_cfg->entry;
---
>     return cp_entry;
> }
> 
> void hal_cmu_cp_boot(uint32_t entry)
> {
>     cmu->CP_VTOR = entry;
> 
>     hal_cmu_clock_enable(HAL_CMU_MOD_H_CACHE1);
>     hal_cmu_reset_clear(HAL_CMU_MOD_H_CACHE1);
> 
>     hal_cmu_clock_enable(HAL_CMU_MOD_H_CP);
>     hal_cmu_reset_clear(HAL_CMU_MOD_H_CP);
> }
> 
> void hal_cmu_jtag_sel(enum HAL_CMU_JTAG_SEL_T sel)
> {
>     uint32_t lock;
> 
>     lock = int_lock();
>     cmu->PERIPH_CLK &= ~CMU_JTAG_SEL_MASK;
>     switch (sel) {
>         case HAL_CMU_JTAG_SEL_CP:
>             cmu->PERIPH_CLK |= CMU_JTAG_SEL_CP;
>             break;
>         case HAL_CMU_JTAG_SEL_A7:
>             cmu->PERIPH_CLK |= CMU_JTAG_SEL_A7;
>             break;
>         default:
>             break;
>     }
>     int_unlock(lock);
> }
> 
> void hal_cmu_dsp_setup(void)
> {
>     hal_sys_timer_open();
> 
>     hal_sysfreq_req(HAL_SYSFREQ_USER_INIT, HAL_CMU_FREQ_390M);
> 
> }
> 
> void hal_cmu_flash0_dual_die()
> {
>     cmu->MCU_TIMER &= ~CMU_FLS1_IO_SEL;
> }
> 
> void hal_cmu_flash1_enable()
> {
>     //aoncmu->FLASH_IOCFG |= AON_CMU_PU_FLASH1_IO;
>     aoncmu->FLASH_IOCFG = SET_BITFIELD(aoncmu->FLASH_IOCFG, AON_CMU_FLASH1_IODRV, 0x7) | AON_CMU_PU_FLASH1_IO;
> }
> 
> void hal_cmu_set_flash0_x8_mode(uint32_t en)
> {
>     if (en)
>         cmu->MCU_TIMER |= CMU_FLS0_X8_SEL;
>     else
>         cmu->MCU_TIMER &= ~CMU_FLS0_X8_SEL;
> }
> 
> void hal_cmu_set_flash0_size(enum HAL_FLASH0_SIZE_CFG cfg)
> {
>     *(volatile uint32_t *)(ICACHE_CTRL_BASE + 0x44) = cfg;
> }
> 
> uint32_t hal_cmu_get_osc_ready_cycle_cnt(void)
> {
>     uint32_t cnt=10;
> 
> 
> 
>     return cnt;
> }
> 
> uint32_t hal_cmu_get_osc_switch_overhead(void)
> {
>         return 6;
> }
> 
> void hal_cmu_bt_sys_set_freq(enum HAL_CMU_FREQ_T freq)
> {
> 
> }
> 
> void hal_cmu_bt_sys_clock_force_on(void)
> {
>     uint32_t lock;
> 
>     lock = int_lock();
>     hal_psc_dslp_force_on_bt_enable();
>     aoncmu->TOP_CLK_ENABLE = AON_CMU_EN_BT_CLK_SYS_ENABLE;
>     int_unlock(lock);
>     aocmu_reg_update_wait();
> }
> 
> void hal_cmu_bt_sys_clock_auto(void)
> {
>     uint32_t lock;
> 
>     lock = int_lock();
>     aoncmu->TOP_CLK_DISABLE = AON_CMU_EN_BT_CLK_SYS_DISABLE;
>     hal_psc_dslp_force_on_bt_disable();
>     int_unlock(lock);
> }
> 
> #ifdef REUSE_WIFI_CALI_RESULT
> extern void save_wifi_cali_result();
> #endif
> 
> void hal_cmu_shutdown_hook(void)
> {
>     int_lock();
>     hal_cmu_codec_clock_disable();
>     hal_cmu_codec_rs_disable();
> 
>     hal_cmu_dsp_reset_set();
>     hal_cmu_dsp_clock_disable();
>     
> #ifdef REUSE_WIFI_CALI_RESULT
>     save_wifi_cali_result();
> #endif
> 
>     hal_cmu_wifi_reset_set();
>     hal_cmu_wifi_clock_disable();
>     hal_cmu_cp_disable();
>     hal_cmu_bt_reset_set();
>     hal_cmu_bt_clock_disable();
> 
>     // hal_norflash_deinit();
> 
>     hal_cmu_mem_set_freq(HAL_CMU_FREQ_26M);
>     hal_cmu_sys_set_freq(HAL_CMU_FREQ_26M);
> 
>     // psramuhsphy_sleep();
>     // hal_psram_phy_sleep();
>     // hal_cmu_pll_disable(HAL_CMU_PLL_BB, HAL_CMU_PLL_USER_ALL);
>     // hal_cmu_pll_disable(HAL_CMU_PLL_BB_PSRAM, HAL_CMU_PLL_USER_ALL);
>     // hal_cmu_pll_disable(HAL_CMU_PLL_DDR, HAL_CMU_PLL_USER_ALL);
>     // hal_cmu_pll_disable(HAL_CMU_PLL_DSP, HAL_CMU_PLL_USER_ALL);
>     // hal_cmu_pll_disable(HAL_CMU_PLL_USB, HAL_CMU_PLL_USER_ALL);
> }
> 
> void hal_cmu_sys_reboot(void)
> {
> #if defined(FLASH_SUSPEND) && defined(FLASH_API_GUARD_THREAD)
>     norflash_api_flush_all();
> #endif
>     hal_cmu_shutdown_hook();
>     hal_cmu_reset_set(HAL_CMU_MOD_GLOBAL);
